{"version":3,"file":"C8hcEfMI.js","sources":["../../../../../../node_modules/paneforge/dist/internal/utils/lifecycle.js","../../../../../../node_modules/paneforge/dist/internal/utils/store.js","../../../../../../node_modules/paneforge/dist/internal/utils/style.js","../../../../../../node_modules/paneforge/dist/internal/utils/aria.js","../../../../../../node_modules/paneforge/dist/internal/utils/id.js","../../../../../../node_modules/paneforge/dist/internal/constants.js","../../../../../../node_modules/paneforge/dist/internal/utils/storage.js","../../../../../../node_modules/paneforge/dist/internal/utils/object.js","../../../../../../node_modules/paneforge/dist/internal/utils/chain.js","../../../../../../node_modules/paneforge/dist/internal/utils/event.js","../../../../../../node_modules/paneforge/dist/internal/utils/compare.js","../../../../../../node_modules/paneforge/dist/internal/utils/assert.js","../../../../../../node_modules/paneforge/dist/internal/utils/resize.js","../../../../../../node_modules/paneforge/dist/internal/utils/adjust-layout.js","../../../../../../node_modules/paneforge/dist/internal/utils/is.js","../../../../../../node_modules/paneforge/dist/internal/paneforge.js","../../../../../../node_modules/paneforge/dist/components/ctx.js","../../../../../../node_modules/paneforge/dist/components/pane-group.svelte","../../../../../../node_modules/paneforge/dist/components/pane.svelte","../../../../../../node_modules/paneforge/dist/components/pane-resizer.js","../../../../../../node_modules/paneforge/dist/components/pane-resizer.svelte","../../../../../../src/lib/components/icons/DocumentArrowUpSolid.svelte","../../../../../../src/lib/components/icons/CameraSolid.svelte"],"sourcesContent":["import { onDestroy } from \"svelte\";\n/**\n * Safely calls `onDestroy` and catches any errors that occur.\n */\nexport function safeOnDestroy(fn) {\n    try {\n        onDestroy(fn);\n    }\n    catch {\n        return fn();\n    }\n}\n","import { isBrowser, safeOnDestroy } from \"./index.js\";\nimport { derived, writable, } from \"svelte/store\";\n/**\n * A utility function that creates a derived store that automatically\n * unsubscribes from its dependencies.\n *\n * Originally written by @tglide for use in Melt UI. <3\n *\n * @template S - The type of the stores object\n * @template T - The type of the derived store\n * @param stores - The stores object to derive from\n * @param fn - The function to derive the store from\n * @returns A derived store that automatically unsubscribes from its dependencies\n */\nexport function derivedWithUnsubscribe(stores, fn) {\n    let unsubscribers = [];\n    const onUnsubscribe = (cb) => {\n        unsubscribers.push(cb);\n    };\n    const unsubscribe = () => {\n        // Call all of the unsubscribe functions from the previous run of the function\n        unsubscribers.forEach((fn) => fn());\n        // Clear the list of unsubscribe functions\n        unsubscribers = [];\n    };\n    const derivedStore = derived(stores, ($storeValues) => {\n        unsubscribe();\n        return fn($storeValues, onUnsubscribe);\n    });\n    safeOnDestroy(unsubscribe);\n    const subscribe = (...args) => {\n        const unsub = derivedStore.subscribe(...args);\n        return () => {\n            unsub();\n            unsubscribe();\n        };\n    };\n    return {\n        ...derivedStore,\n        subscribe,\n    };\n}\n/**\n * A utility function that creates an effect from a set of stores and a function.\n * The effect is automatically cleaned up when the component is destroyed.\n *\n * Originally written by @tglide for use in Melt UI. <3\n *\n * @template S - The type of the stores object\n * @param stores - The stores object to derive from\n * @param fn - The function to run when the stores change\n * @returns A function that can be used to unsubscribe the effect\n */\nexport function clientEffect(stores, fn) {\n    if (!isBrowser)\n        return () => { };\n    // Create a derived store that contains the stores object and an onUnsubscribe function\n    const unsub = derivedWithUnsubscribe(stores, (stores, onUnsubscribe) => {\n        return {\n            stores,\n            onUnsubscribe,\n        };\n    }).subscribe(({ stores, onUnsubscribe }) => {\n        const returned = fn(stores);\n        // If the function returns a cleanup function, call it when the effect is unsubscribed\n        if (returned) {\n            onUnsubscribe(returned);\n        }\n    });\n    // Automatically unsubscribe the effect when the component is destroyed\n    safeOnDestroy(unsub);\n    return unsub;\n}\n/**\n * Given an object of properties, returns an object of writable stores\n * with the same properties and values.\n */\nexport function toWritableStores(properties) {\n    const result = {};\n    Object.keys(properties).forEach((key) => {\n        const propertyKey = key;\n        const value = properties[propertyKey];\n        result[propertyKey] = writable(value);\n    });\n    return result;\n}\n/**\n * Returns a function that can be used to update the values of options\n * in a store based on the modification of a prop.\n */\nexport function getOptionUpdater(options) {\n    return function (key, value) {\n        if (value === undefined)\n            return;\n        const store = options[key];\n        if (store) {\n            store.set(value);\n        }\n    };\n}\n","/**\n * A utility function that converts a style object to a string,\n * which can be used as the value of the `style` attribute for\n * an element.\n *\n * @param style - The style object to convert\n * @returns The style object as a string\n */\nexport function styleToString(style) {\n    return Object.keys(style).reduce((str, key) => {\n        if (style[key] === undefined)\n            return str;\n        return str + `${key}:${style[key]};`;\n    }, \"\");\n}\n/* Global cursor state */\nlet currentState = null;\n/* Global cursor element */\nlet element = null;\n/**\n * Returns the cursor style for a given cursor state.\n */\nexport function getCursorStyle(state) {\n    switch (state) {\n        case \"horizontal\":\n            return \"ew-resize\";\n        case \"horizontal-max\":\n            return \"w-resize\";\n        case \"horizontal-min\":\n            return \"e-resize\";\n        case \"vertical\":\n            return \"ns-resize\";\n        case \"vertical-max\":\n            return \"n-resize\";\n        case \"vertical-min\":\n            return \"s-resize\";\n    }\n}\n/**\n * Resets the global cursor style to the default.\n */\nexport function resetGlobalCursorStyle() {\n    if (element === null)\n        return;\n    document.head.removeChild(element);\n    currentState = null;\n    element = null;\n}\n/**\n * Sets the global cursor style to the given state.\n */\nexport function setGlobalCursorStyle(state) {\n    if (currentState === state)\n        return;\n    currentState = state;\n    const style = getCursorStyle(state);\n    if (element === null) {\n        element = document.createElement(\"style\");\n        document.head.appendChild(element);\n    }\n    element.innerHTML = `*{cursor: ${style}!important;}`;\n}\n/**\n * Computes the flexbox style for a pane given its layout and drag state.\n */\nexport function computePaneFlexBoxStyle({ defaultSize, dragState, layout, paneData, paneIndex, precision = 3, }) {\n    const size = layout[paneIndex];\n    let flexGrow;\n    if (size == null) {\n        // Initial render (before panes have registered themselves)\n        // To support server rendering, fallback to default size\n        flexGrow = defaultSize ?? \"1\";\n    }\n    else if (paneData.length === 1) {\n        //  Single pane group should always fill full width/height\n        flexGrow = \"1\";\n    }\n    else {\n        flexGrow = size.toPrecision(precision);\n    }\n    return styleToString({\n        \"flex-basis\": 0,\n        \"flex-grow\": flexGrow,\n        \"flex-shrink\": 1,\n        // Without this, pane sizes may be unintentionally overridden by their content\n        overflow: \"hidden\",\n        // Disable pointer events inside of a pane during resize\n        // This avoid edge cases like nested iframes\n        \"pointer-events\": dragState !== null ? \"none\" : undefined,\n    });\n}\n","/**\n * A utility function that calculates the `aria-valuemax`, `aria-valuemin`,\n * and `aria-valuenow` values for a pane based on its layout and constraints.\n */\nexport function calculateAriaValues({ layout, panesArray, pivotIndices, }) {\n    let currentMinSize = 0;\n    let currentMaxSize = 100;\n    let totalMinSize = 0;\n    let totalMaxSize = 0;\n    const firstIndex = pivotIndices[0];\n    // A pane's effective min/max sizes also need to account for other pane's sizes.\n    for (let i = 0; i < panesArray.length; i++) {\n        const { constraints } = panesArray[i];\n        const { maxSize = 100, minSize = 0 } = constraints;\n        if (i === firstIndex) {\n            currentMinSize = minSize;\n            currentMaxSize = maxSize;\n        }\n        else {\n            totalMinSize += minSize;\n            totalMaxSize += maxSize;\n        }\n    }\n    const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n    const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n    const valueNow = layout[firstIndex];\n    return {\n        valueMax,\n        valueMin,\n        valueNow,\n    };\n}\n","import { nanoid } from \"nanoid/non-secure\";\n/**\n * If an id is provided return it, otherwise generate a new id and return that.\n */\nexport function generateId(idFromProps = null) {\n    if (idFromProps == null)\n        return nanoid(10);\n    return idFromProps;\n}\n","export const LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nexport const PRECISION = 10;\n","import { get } from \"svelte/store\";\nimport { LOCAL_STORAGE_DEBOUNCE_INTERVAL } from \"../constants.js\";\n/**\n * Initializes the storage object with the appropriate getItem\n *  and setItem functions depending on the environment (browser or not).\n */\nexport function initializeStorage(storageObject) {\n    try {\n        if (typeof localStorage === \"undefined\") {\n            throw new Error(\"localStorage is not supported in this environment\");\n        }\n        storageObject.getItem = (name) => localStorage.getItem(name);\n        storageObject.setItem = (name, value) => localStorage.setItem(name, value);\n    }\n    catch (err) {\n        // eslint-disable-next-line no-console\n        console.error(err);\n        storageObject.getItem = () => null;\n        storageObject.setItem = () => { };\n    }\n}\n/**\n * Returns the key to use for storing the pane group state in local storage.\n */\nfunction getPaneGroupKey(autoSaveId) {\n    return `paneforge:${autoSaveId}`;\n}\n/**\n * Returns a key to use for storing the pane state in local storage.\n * The key is based on the pane order and constraints.\n */\nfunction getPaneKey(panes) {\n    const sortedPaneIds = panes\n        .map((pane) => {\n        const { constraints, id, idIsFromProps, order } = pane;\n        return idIsFromProps\n            ? id\n            : order\n                ? `${order}:${JSON.stringify(constraints)}`\n                : JSON.stringify(constraints);\n    })\n        .sort()\n        .join(\",\");\n    return sortedPaneIds;\n}\n/**\n * Loads the serialized pane group state from local storage.\n * If the state is not found, returns null.\n */\nfunction loadSerializedPaneGroupState(autoSaveId, storage) {\n    try {\n        const paneGroupKey = getPaneGroupKey(autoSaveId);\n        const serialized = storage.getItem(paneGroupKey);\n        const parsed = JSON.parse(serialized || \"\");\n        if (typeof parsed === \"object\" && parsed !== null) {\n            return parsed;\n        }\n    }\n    catch {\n        // noop\n    }\n    return null;\n}\n/**\n * Loads the pane group state from local storage.\n * If the state is not found, returns null.\n */\nexport function loadPaneGroupState(autoSaveId, panes, storage) {\n    const state = loadSerializedPaneGroupState(autoSaveId, storage) || {};\n    const paneKey = getPaneKey(panes);\n    return state[paneKey] || null;\n}\n/**\n * Saves the pane group state to local storage.\n */\nexport function savePaneGroupState(autoSaveId, panes, paneSizesBeforeCollapse, sizes, storage) {\n    const paneGroupKey = getPaneGroupKey(autoSaveId);\n    const paneKey = getPaneKey(panes);\n    const state = loadSerializedPaneGroupState(autoSaveId, storage) || {};\n    state[paneKey] = {\n        expandToSizes: Object.fromEntries(paneSizesBeforeCollapse.entries()),\n        layout: sizes,\n    };\n    try {\n        storage.setItem(paneGroupKey, JSON.stringify(state));\n    }\n    catch (error) {\n        // eslint-disable-next-line no-console\n        console.error(error);\n    }\n}\nconst debounceMap = {};\n/**\n * Returns a debounced version of the given function.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction debounce(callback, durationMs = 10) {\n    let timeoutId = null;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const callable = (...args) => {\n        if (timeoutId !== null) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(() => {\n            callback(...args);\n        }, durationMs);\n    };\n    return callable;\n}\n/**\n * Updates the values in local storage based on the current state of\n * the pane group.\n * This function is debounced to limit the frequency of local storage writes.\n */\nexport function updateStorageValues({ autoSaveId, layout, storage, paneDataArrayStore, paneSizeBeforeCollapseStore, }) {\n    const $paneDataArray = get(paneDataArrayStore);\n    // If this pane has been configured to persist sizing\n    // information, save sizes to local storage.\n    if (layout.length === 0 || layout.length !== $paneDataArray.length)\n        return;\n    let debouncedSave = debounceMap[autoSaveId];\n    // Limit frequency of local storage writes.\n    if (debouncedSave == null) {\n        debouncedSave = debounce(savePaneGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n        debounceMap[autoSaveId] = debouncedSave;\n    }\n    // Clone mutable data before passing to the debounced function,\n    // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n    const clonedPaneDataArray = [...$paneDataArray];\n    const $paneSizeBeforeCollapse = get(paneSizeBeforeCollapseStore);\n    const clonedPaneSizesBeforeCollapse = new Map($paneSizeBeforeCollapse);\n    debouncedSave(autoSaveId, clonedPaneDataArray, clonedPaneSizesBeforeCollapse, layout, storage);\n}\n","/**\n * Removes all undefined properties from the given object.\n */\nexport function removeUndefined(obj) {\n    const result = {};\n    for (const key in obj) {\n        const value = obj[key];\n        if (value !== undefined) {\n            result[key] = value;\n        }\n    }\n    return result;\n}\n","/**\n * Executes an array of callback functions with the same arguments.\n * @template T The types of the arguments that the callback functions take.\n * @param n array of callback functions to execute.\n * @returns A new function that executes all of the original callback functions with the same arguments.\n */\nexport function chain(...callbacks) {\n    return (...args) => {\n        for (const callback of callbacks) {\n            if (typeof callback === \"function\") {\n                callback(...args);\n            }\n        }\n    };\n}\n","/**\n * Adds an event listener to the specified target element(s) for the given event(s), and returns a function to remove it.\n * @param target The target element(s) to add the event listener to.\n * @param event The event(s) to listen for.\n * @param handler The function to be called when the event is triggered.\n * @param options An optional object that specifies characteristics about the event listener.\n * @returns A function that removes the event listener from the target element(s).\n */\nexport function addEventListener(target, event, handler, options) {\n    const events = Array.isArray(event) ? event : [event];\n    // Add the event listener to each specified event for the target element(s).\n    events.forEach((_event) => target.addEventListener(_event, handler, options));\n    // Return a function that removes the event listener from the target element(s).\n    return () => {\n        events.forEach((_event) => target.removeEventListener(_event, handler, options));\n    };\n}\n","import { PRECISION } from \"../constants.js\";\n/**\n * Compares two numbers for equality with a given fractional precision.\n */\nexport function areNumbersAlmostEqual(actual, expected, fractionDigits = PRECISION) {\n    return compareNumbersWithTolerance(actual, expected, fractionDigits) === 0;\n}\n/**\n * Compares two numbers with a given tolerance.\n *\n * @returns `-1` if `actual` is less than `expected`, `0` if they are equal,\n * and `1` if `actual` is greater than `expected`.\n */\nexport function compareNumbersWithTolerance(actual, expected, fractionDigits = PRECISION) {\n    const roundedActual = roundTo(actual, fractionDigits);\n    const roundedExpected = roundTo(expected, fractionDigits);\n    return Math.sign(roundedActual - roundedExpected);\n}\n/**\n * Compares two arrays for equality.\n */\nexport function areArraysEqual(arrA, arrB) {\n    if (arrA.length !== arrB.length)\n        return false;\n    for (let index = 0; index < arrA.length; index++) {\n        if (arrA[index] !== arrB[index])\n            return false;\n    }\n    return true;\n}\n/**\n * Rounds a number to a given number of decimal places.\n */\nfunction roundTo(value, decimals) {\n    return parseFloat(value.toFixed(decimals));\n}\n","export function assert(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexpectedCondition, message = \"Assertion failed!\") {\n    if (!expectedCondition) {\n        // eslint-disable-next-line no-console\n        console.error(message);\n        throw Error(message);\n    }\n}\n","import { PRECISION } from \"../constants.js\";\nimport { assert } from \"./assert.js\";\nimport { compareNumbersWithTolerance } from \"./compare.js\";\n/**\n * Resizes a pane based on its constraints.\n */\nexport function resizePane({ paneConstraints: paneConstraintsArray, paneIndex, initialSize, }) {\n    const paneConstraints = paneConstraintsArray[paneIndex];\n    assert(paneConstraints != null, \"Pane constraints should not be null.\");\n    const { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = paneConstraints;\n    let newSize = initialSize;\n    if (compareNumbersWithTolerance(newSize, minSize) < 0) {\n        newSize = getAdjustedSizeForCollapsible(newSize, collapsible, collapsedSize, minSize);\n    }\n    newSize = Math.min(maxSize, newSize);\n    return parseFloat(newSize.toFixed(PRECISION));\n}\n/**\n * Adjusts the size of a pane based on its collapsible state.\n *\n * If the pane is collapsible, the size will be snapped to the collapsed size\n * or the minimum size based on the halfway point.\n */\nfunction getAdjustedSizeForCollapsible(size, collapsible, collapsedSize, minSize) {\n    if (!collapsible)\n        return minSize;\n    // Snap collapsible panes closed or open based on the halfway point.\n    const halfwayPoint = (collapsedSize + minSize) / 2;\n    return compareNumbersWithTolerance(size, halfwayPoint) < 0 ? collapsedSize : minSize;\n}\n","import { assert } from \"./assert.js\";\nimport { compareNumbersWithTolerance, areNumbersAlmostEqual, resizePane, } from \"./index.js\";\n/**\n * Adjusts the layout of panes based on the delta of the resize handle.\n * All units must be in percentages; pixel values should be pre-converted.\n *\n * Credit: https://github.com/bvaughn/react-resizable-panels\n */\nexport function adjustLayoutByDelta({ delta, layout: prevLayout, paneConstraints: paneConstraintsArray, pivotIndices, trigger, }) {\n    if (areNumbersAlmostEqual(delta, 0))\n        return prevLayout;\n    const nextLayout = [...prevLayout];\n    const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n    let deltaApplied = 0;\n    // A resizing pane affects the panes before or after it.\n    //\n    // A negative delta means the pane(s) immediately after the resize handle should grow/expand by decreasing its offset.\n    // Other panes may also need to shrink/contract (and shift) to make room, depending on the min weights.\n    //\n    // A positive delta means the pane(s) immediately before the resize handle should \"expand\".\n    // This is accomplished by shrinking/contracting (and shifting) one or more of the panes after the resize handle.\n    {\n        // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n        // We no longer check the halfway threshold because this may prevent the pane from expanding at all.\n        if (trigger === \"keyboard\") {\n            {\n                // Check if we should expand a collapsed pane\n                const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n                const paneConstraints = paneConstraintsArray[index];\n                assert(paneConstraints);\n                if (paneConstraints.collapsible) {\n                    const prevSize = prevLayout[index];\n                    assert(prevSize != null);\n                    const paneConstraints = paneConstraintsArray[index];\n                    assert(paneConstraints);\n                    const { collapsedSize = 0, minSize = 0 } = paneConstraints;\n                    if (areNumbersAlmostEqual(prevSize, collapsedSize)) {\n                        const localDelta = minSize - prevSize;\n                        //DEBUG.push(`  -> expand delta: ${localDelta}`);\n                        if (compareNumbersWithTolerance(localDelta, Math.abs(delta)) > 0) {\n                            delta = delta < 0 ? 0 - localDelta : localDelta;\n                            //DEBUG.push(`  -> delta: ${delta}`);\n                        }\n                    }\n                }\n            }\n            {\n                // Check if we should collapse a pane at its minimum size\n                const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n                const paneConstraints = paneConstraintsArray[index];\n                assert(paneConstraints);\n                const { collapsible } = paneConstraints;\n                if (collapsible) {\n                    const prevSize = prevLayout[index];\n                    assert(prevSize != null);\n                    const paneConstraints = paneConstraintsArray[index];\n                    assert(paneConstraints);\n                    const { collapsedSize = 0, minSize = 0 } = paneConstraints;\n                    if (areNumbersAlmostEqual(prevSize, minSize)) {\n                        const localDelta = prevSize - collapsedSize;\n                        if (compareNumbersWithTolerance(localDelta, Math.abs(delta)) > 0) {\n                            delta = delta < 0 ? 0 - localDelta : localDelta;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    {\n        // Pre-calculate max available delta in the opposite direction of our pivot.\n        // This will be the maximum amount we're allowed to expand/contract the panes in the primary direction.\n        // If this amount is less than the requested delta, adjust the requested delta.\n        // If this amount is greater than the requested delta, that's useful information too–\n        // as an expanding pane might change from collapsed to min size.\n        const increment = delta < 0 ? 1 : -1;\n        let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        let maxAvailableDelta = 0;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const prevSize = prevLayout[index];\n            assert(prevSize != null);\n            const maxSafeSize = resizePane({\n                paneConstraints: paneConstraintsArray,\n                paneIndex: index,\n                initialSize: 100,\n            });\n            const delta = maxSafeSize - prevSize;\n            maxAvailableDelta += delta;\n            index += increment;\n            if (index < 0 || index >= paneConstraintsArray.length) {\n                break;\n            }\n        }\n        const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n        delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    }\n    {\n        // Delta added to a pane needs to be subtracted from other panes (within the constraints that those panes allow).\n        const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        let index = pivotIndex;\n        while (index >= 0 && index < paneConstraintsArray.length) {\n            const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n            const prevSize = prevLayout[index];\n            assert(prevSize != null);\n            const unsafeSize = prevSize - deltaRemaining;\n            const safeSize = resizePane({\n                paneConstraints: paneConstraintsArray,\n                paneIndex: index,\n                initialSize: unsafeSize,\n            });\n            if (!areNumbersAlmostEqual(prevSize, safeSize)) {\n                deltaApplied += prevSize - safeSize;\n                nextLayout[index] = safeSize;\n                if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n                    numeric: true,\n                }) >= 0) {\n                    break;\n                }\n            }\n            if (delta < 0) {\n                index--;\n            }\n            else {\n                index++;\n            }\n        }\n    }\n    // If we were unable to resize any of the panes, return the previous state.\n    // This will essentially bailout and ignore e.g. drags past a pane's boundaries\n    if (areNumbersAlmostEqual(deltaApplied, 0)) {\n        return prevLayout;\n    }\n    {\n        // Now distribute the applied delta to the panes in the other direction\n        const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const prevSize = prevLayout[pivotIndex];\n        assert(prevSize != null);\n        const unsafeSize = prevSize + deltaApplied;\n        const safeSize = resizePane({\n            paneConstraints: paneConstraintsArray,\n            paneIndex: pivotIndex,\n            initialSize: unsafeSize,\n        });\n        // Adjust the pivot pane before, but only by the amount that surrounding panes were able to shrink/contract.\n        nextLayout[pivotIndex] = safeSize;\n        // Edge case where expanding or contracting one pane caused another one to change collapsed state\n        if (!areNumbersAlmostEqual(safeSize, unsafeSize)) {\n            let deltaRemaining = unsafeSize - safeSize;\n            const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n            let index = pivotIndex;\n            while (index >= 0 && index < paneConstraintsArray.length) {\n                const prevSize = nextLayout[index];\n                assert(prevSize != null);\n                const unsafeSize = prevSize + deltaRemaining;\n                const safeSize = resizePane({\n                    paneConstraints: paneConstraintsArray,\n                    paneIndex: index,\n                    initialSize: unsafeSize,\n                });\n                if (!areNumbersAlmostEqual(prevSize, safeSize)) {\n                    deltaRemaining -= safeSize - prevSize;\n                    nextLayout[index] = safeSize;\n                }\n                if (areNumbersAlmostEqual(deltaRemaining, 0))\n                    break;\n                delta > 0 ? index-- : index++;\n            }\n        }\n    }\n    const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n    if (!areNumbersAlmostEqual(totalSize, 100))\n        return prevLayout;\n    return nextLayout;\n}\n","export const isBrowser = typeof document !== \"undefined\";\nexport function isHTMLElement(element) {\n    return element instanceof HTMLElement;\n}\nexport function isKeyDown(event) {\n    return event.type === \"keydown\";\n}\nexport function isMouseEvent(event) {\n    return event.type.startsWith(\"mouse\");\n}\nexport function isTouchEvent(event) {\n    return event.type.startsWith(\"touch\");\n}\n","import { initializeStorage, loadPaneGroupState, resizePane, resetGlobalCursorStyle, setGlobalCursorStyle, updateStorageValues, adjustLayoutByDelta, areNumbersAlmostEqual, areArraysEqual, generateId, removeUndefined, clientEffect, toWritableStores, calculateAriaValues, addEventListener, computePaneFlexBoxStyle, styleToString, isBrowser, isHTMLElement, isKeyDown, isMouseEvent, isTouchEvent, } from \"./utils/index.js\";\nimport { derived, get, writable } from \"svelte/store\";\nimport { assert } from \"./utils/assert.js\";\nimport { onMount } from \"svelte\";\nexport const defaultStorage = {\n    getItem: (name) => {\n        initializeStorage(defaultStorage);\n        return defaultStorage.getItem(name);\n    },\n    setItem: (name, value) => {\n        initializeStorage(defaultStorage);\n        defaultStorage.setItem(name, value);\n    },\n};\nconst defaultProps = {\n    id: null,\n    onLayout: null,\n    keyboardResizeBy: null,\n    autoSaveId: null,\n    direction: \"horizontal\",\n    storage: defaultStorage,\n};\nexport function createPaneForge(props) {\n    const withDefaults = {\n        ...defaultProps,\n        ...removeUndefined(props),\n    };\n    const options = toWritableStores(withDefaults);\n    const { autoSaveId, direction, keyboardResizeBy, storage, onLayout } = options;\n    const groupId = writable(generateId());\n    const dragState = writable(null);\n    const layout = writable([]);\n    const paneDataArray = writable([]);\n    const paneDataArrayChanged = writable(false);\n    const paneIdToLastNotifiedSizeMap = writable({});\n    const paneSizeBeforeCollapseMap = writable(new Map());\n    const prevDelta = writable(0);\n    clientEffect([groupId, layout, paneDataArray], ([$groupId, $layout, $paneDataArray]) => {\n        const unsub = updateResizeHandleAriaValues({\n            groupId: $groupId,\n            layout: $layout,\n            paneDataArray: $paneDataArray,\n        });\n        return unsub;\n    });\n    onMount(() => {\n        const unsub = setResizeHandlerEventListeners();\n        return unsub;\n    });\n    clientEffect([autoSaveId, layout, storage], ([$autoSaveId, $layout, $storage]) => {\n        if (!$autoSaveId)\n            return;\n        updateStorageValues({\n            autoSaveId: $autoSaveId,\n            layout: $layout,\n            storage: $storage,\n            paneDataArrayStore: paneDataArray,\n            paneSizeBeforeCollapseStore: paneSizeBeforeCollapseMap,\n        });\n    });\n    function collapsePane(paneData) {\n        const $prevLayout = get(layout);\n        const $paneDataArray = get(paneDataArray);\n        if (!paneData.constraints.collapsible)\n            return;\n        const paneConstraintsArray = $paneDataArray.map((paneData) => paneData.constraints);\n        const { collapsedSize = 0, paneSize, pivotIndices, } = paneDataHelper($paneDataArray, paneData, $prevLayout);\n        assert(paneSize != null);\n        if (paneSize === collapsedSize)\n            return;\n        // Store the size before collapse, which is returned when `expand()` is called\n        paneSizeBeforeCollapseMap.update((curr) => {\n            curr.set(paneData.id, paneSize);\n            return curr;\n        });\n        const isLastPane = findPaneDataIndex($paneDataArray, paneData) === $paneDataArray.length - 1;\n        const delta = isLastPane ? paneSize - collapsedSize : collapsedSize - paneSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            layout: $prevLayout,\n            paneConstraints: paneConstraintsArray,\n            pivotIndices,\n            trigger: \"imperative-api\",\n        });\n        if (areArraysEqual($prevLayout, nextLayout))\n            return;\n        layout.set(nextLayout);\n        const $onLayout = get(onLayout);\n        if ($onLayout) {\n            $onLayout(nextLayout);\n        }\n        callPaneCallbacks($paneDataArray, nextLayout, get(paneIdToLastNotifiedSizeMap));\n    }\n    function getPaneSize(paneData) {\n        const $layout = get(layout);\n        const $paneDataArray = get(paneDataArray);\n        const { paneSize } = paneDataHelper($paneDataArray, paneData, $layout);\n        return paneSize;\n    }\n    const getPaneStyle = derived([paneDataArray, layout, dragState], ([$paneDataArray, $layout, $dragState]) => {\n        return (paneData, defaultSize) => {\n            const paneIndex = findPaneDataIndex($paneDataArray, paneData);\n            return computePaneFlexBoxStyle({\n                defaultSize,\n                dragState: $dragState,\n                layout: $layout,\n                paneData: $paneDataArray,\n                paneIndex,\n            });\n        };\n    });\n    function isPaneExpanded(paneData) {\n        const $paneDataArray = get(paneDataArray);\n        const $layout = get(layout);\n        const { collapsedSize = 0, collapsible, paneSize, } = paneDataHelper($paneDataArray, paneData, $layout);\n        return !collapsible || paneSize > collapsedSize;\n    }\n    function registerPane(paneData) {\n        paneDataArray.update((curr) => {\n            const newArr = [...curr, paneData];\n            newArr.sort((paneA, paneB) => {\n                const orderA = paneA.order;\n                const orderB = paneB.order;\n                if (orderA == null && orderB == null) {\n                    return 0;\n                }\n                else if (orderA == null) {\n                    return -1;\n                }\n                else if (orderB == null) {\n                    return 1;\n                }\n                else {\n                    return orderA - orderB;\n                }\n            });\n            return newArr;\n        });\n        paneDataArrayChanged.set(true);\n    }\n    clientEffect([paneDataArrayChanged], ([$paneDataArrayChanged]) => {\n        if (!$paneDataArrayChanged)\n            return;\n        paneDataArrayChanged.set(false);\n        const $autoSaveId = get(autoSaveId);\n        const $storage = get(storage);\n        const $prevLayout = get(layout);\n        const $paneDataArray = get(paneDataArray);\n        // If this pane has been configured to persist sizing information,\n        // default size should be restored from local storage if possible.\n        let unsafeLayout = null;\n        if ($autoSaveId) {\n            const state = loadPaneGroupState($autoSaveId, $paneDataArray, $storage);\n            if (state) {\n                paneSizeBeforeCollapseMap.set(new Map(Object.entries(state.expandToSizes)));\n                unsafeLayout = state.layout;\n            }\n        }\n        if (unsafeLayout == null) {\n            unsafeLayout = getUnsafeDefaultLayout({\n                paneDataArray: $paneDataArray,\n            });\n        }\n        // Validate even saved layouts in case something has changed since last render\n        const nextLayout = validatePaneGroupLayout({\n            layout: unsafeLayout,\n            paneConstraints: $paneDataArray.map((paneData) => paneData.constraints),\n        });\n        if (areArraysEqual($prevLayout, nextLayout))\n            return;\n        layout.set(nextLayout);\n        const $onLayout = get(onLayout);\n        if ($onLayout) {\n            $onLayout(nextLayout);\n        }\n        callPaneCallbacks($paneDataArray, nextLayout, get(paneIdToLastNotifiedSizeMap));\n    });\n    function registerResizeHandle(dragHandleId) {\n        return function resizeHandler(event) {\n            event.preventDefault();\n            const $direction = get(direction);\n            const $dragState = get(dragState);\n            const $groupId = get(groupId);\n            const $keyboardResizeBy = get(keyboardResizeBy);\n            const $prevLayout = get(layout);\n            const $paneDataArray = get(paneDataArray);\n            const { initialLayout } = $dragState ?? {};\n            const pivotIndices = getPivotIndices($groupId, dragHandleId);\n            let delta = getDeltaPercentage(event, dragHandleId, $direction, $dragState, $keyboardResizeBy);\n            if (delta === 0)\n                return;\n            // support RTL\n            const isHorizontal = $direction === \"horizontal\";\n            if (document.dir === \"rtl\" && isHorizontal) {\n                delta = -delta;\n            }\n            const paneConstraints = $paneDataArray.map((paneData) => paneData.constraints);\n            const nextLayout = adjustLayoutByDelta({\n                delta,\n                layout: initialLayout ?? $prevLayout,\n                paneConstraints: paneConstraints,\n                pivotIndices,\n                trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\",\n            });\n            const layoutChanged = !areArraysEqual($prevLayout, nextLayout);\n            // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n            // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n            if (isMouseEvent(event) || isTouchEvent(event)) {\n                // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n                // In this case, Pane sizes might not change–\n                // but updating cursor in this scenario would cause a flicker.\n                const $prevDelta = get(prevDelta);\n                if ($prevDelta != delta) {\n                    prevDelta.set(delta);\n                    if (!layoutChanged) {\n                        // If the pointer has moved too far to resize the pane any further,\n                        // update the cursor style for a visual clue.\n                        // This mimics VS Code behavior.\n                        if (isHorizontal) {\n                            setGlobalCursorStyle(delta < 0 ? \"horizontal-min\" : \"horizontal-max\");\n                        }\n                        else {\n                            setGlobalCursorStyle(delta < 0 ? \"vertical-min\" : \"vertical-max\");\n                        }\n                    }\n                    else {\n                        setGlobalCursorStyle(isHorizontal ? \"horizontal\" : \"vertical\");\n                    }\n                }\n            }\n            if (layoutChanged) {\n                layout.set(nextLayout);\n                const $onLayout = get(onLayout);\n                if ($onLayout) {\n                    $onLayout(nextLayout);\n                }\n                callPaneCallbacks($paneDataArray, nextLayout, get(paneIdToLastNotifiedSizeMap));\n            }\n        };\n    }\n    function resizePane(paneData, unsafePaneSize) {\n        const $prevLayout = get(layout);\n        const $paneDataArray = get(paneDataArray);\n        const paneConstraintsArr = $paneDataArray.map((paneData) => paneData.constraints);\n        const { paneSize, pivotIndices } = paneDataHelper($paneDataArray, paneData, $prevLayout);\n        assert(paneSize != null);\n        const isLastPane = findPaneDataIndex($paneDataArray, paneData) === $paneDataArray.length - 1;\n        const delta = isLastPane ? paneSize - unsafePaneSize : unsafePaneSize - paneSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            layout: $prevLayout,\n            paneConstraints: paneConstraintsArr,\n            pivotIndices,\n            trigger: \"imperative-api\",\n        });\n        if (areArraysEqual($prevLayout, nextLayout))\n            return;\n        layout.set(nextLayout);\n        const $onLayout = get(onLayout);\n        $onLayout?.(nextLayout);\n        callPaneCallbacks($paneDataArray, nextLayout, get(paneIdToLastNotifiedSizeMap));\n    }\n    function startDragging(dragHandleId, event) {\n        const $direction = get(direction);\n        const $layout = get(layout);\n        const handleElement = getResizeHandleElement(dragHandleId);\n        assert(handleElement);\n        const initialCursorPosition = getResizeEventCursorPosition($direction, event);\n        dragState.set({\n            dragHandleId,\n            dragHandleRect: handleElement.getBoundingClientRect(),\n            initialCursorPosition,\n            initialLayout: $layout,\n        });\n    }\n    function stopDragging() {\n        resetGlobalCursorStyle();\n        dragState.set(null);\n    }\n    function unregisterPane(paneData) {\n        const $paneDataArray = get(paneDataArray);\n        const index = findPaneDataIndex($paneDataArray, paneData);\n        if (index < 0)\n            return;\n        paneDataArray.update((curr) => {\n            curr.splice(index, 1);\n            paneIdToLastNotifiedSizeMap.update((curr) => {\n                delete curr[paneData.id];\n                return curr;\n            });\n            paneDataArrayChanged.set(true);\n            return curr;\n        });\n    }\n    function isPaneCollapsed(paneData) {\n        const $paneDataArray = get(paneDataArray);\n        const $layout = get(layout);\n        const { collapsedSize = 0, collapsible, paneSize, } = paneDataHelper($paneDataArray, paneData, $layout);\n        return collapsible === true && paneSize === collapsedSize;\n    }\n    function expandPane(paneData) {\n        const $prevLayout = get(layout);\n        const $paneDataArray = get(paneDataArray);\n        if (!paneData.constraints.collapsible)\n            return;\n        const paneConstraintsArray = $paneDataArray.map((paneData) => paneData.constraints);\n        const { collapsedSize = 0, paneSize, minSize = 0, pivotIndices, } = paneDataHelper($paneDataArray, paneData, $prevLayout);\n        if (paneSize !== collapsedSize)\n            return;\n        // Restore this pane to the size it was before it was collapsed, if possible.\n        const prevPaneSize = get(paneSizeBeforeCollapseMap).get(paneData.id);\n        const baseSize = prevPaneSize != null && prevPaneSize >= minSize ? prevPaneSize : minSize;\n        const isLastPane = findPaneDataIndex($paneDataArray, paneData) === $paneDataArray.length - 1;\n        const delta = isLastPane ? paneSize - baseSize : baseSize - paneSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            layout: $prevLayout,\n            paneConstraints: paneConstraintsArray,\n            pivotIndices,\n            trigger: \"imperative-api\",\n        });\n        if (areArraysEqual($prevLayout, nextLayout))\n            return;\n        layout.set(nextLayout);\n        const $onLayout = get(onLayout);\n        $onLayout?.(nextLayout);\n        callPaneCallbacks($paneDataArray, nextLayout, get(paneIdToLastNotifiedSizeMap));\n    }\n    const paneGroupStyle = derived([direction], ([$direction]) => {\n        return styleToString({\n            display: \"flex\",\n            \"flex-direction\": $direction === \"horizontal\" ? \"row\" : \"column\",\n            height: \"100%\",\n            overflow: \"hidden\",\n            width: \"100%\",\n        });\n    });\n    const paneGroupSelectors = derived([direction, groupId], ([$direction, $groupId]) => {\n        return {\n            \"data-pane-group\": \"\",\n            \"data-direction\": $direction,\n            \"data-pane-group-id\": $groupId,\n        };\n    });\n    const paneGroupAttrs = derived([paneGroupStyle, paneGroupSelectors], ([$style, $selectors]) => {\n        return {\n            style: $style,\n            ...$selectors,\n        };\n    });\n    function setResizeHandlerEventListeners() {\n        const $groupId = get(groupId);\n        const handles = getResizeHandleElementsForGroup($groupId);\n        const unsubHandlers = handles.map((handle) => {\n            const handleId = handle.getAttribute(\"data-pane-resizer-id\");\n            if (!handleId)\n                return noop;\n            const [idBefore, idAfter] = getResizeHandlePaneIds($groupId, handleId, get(paneDataArray));\n            if (idBefore == null || idAfter == null)\n                return noop;\n            const onKeydown = (e) => {\n                if (e.defaultPrevented || e.key !== \"Enter\")\n                    return;\n                e.preventDefault();\n                const $paneDataArray = get(paneDataArray);\n                const index = $paneDataArray.findIndex((paneData) => paneData.id === idBefore);\n                if (index < 0)\n                    return;\n                const paneData = $paneDataArray[index];\n                assert(paneData);\n                const $layout = get(layout);\n                const size = $layout[index];\n                const { collapsedSize = 0, collapsible, minSize = 0 } = paneData.constraints;\n                if (!(size != null && collapsible))\n                    return;\n                const nextLayout = adjustLayoutByDelta({\n                    delta: areNumbersAlmostEqual(size, collapsedSize) ? minSize - size : collapsedSize - size,\n                    layout: $layout,\n                    paneConstraints: $paneDataArray.map((paneData) => paneData.constraints),\n                    pivotIndices: getPivotIndices($groupId, handleId),\n                    trigger: \"keyboard\",\n                });\n                if ($layout !== nextLayout) {\n                    layout.set(nextLayout);\n                }\n            };\n            const unsubListener = addEventListener(handle, \"keydown\", onKeydown);\n            return () => {\n                unsubListener();\n            };\n        });\n        return () => {\n            unsubHandlers.forEach((unsub) => unsub());\n        };\n    }\n    function setLayout(newLayout) {\n        layout.set(newLayout);\n    }\n    function getLayout() {\n        return get(layout);\n    }\n    return {\n        methods: {\n            collapsePane,\n            expandPane,\n            getSize: getPaneSize,\n            getPaneStyle,\n            isCollapsed: isPaneCollapsed,\n            isExpanded: isPaneExpanded,\n            registerPane,\n            registerResizeHandle,\n            resizePane,\n            startDragging,\n            stopDragging,\n            unregisterPane,\n            setLayout,\n            getLayout,\n        },\n        states: {\n            direction,\n            dragState,\n            groupId,\n            paneGroupAttrs,\n            paneGroupSelectors,\n            paneGroupStyle,\n            layout,\n        },\n        options,\n    };\n}\nfunction updateResizeHandleAriaValues({ groupId, layout, paneDataArray, }) {\n    const resizeHandleElements = getResizeHandleElementsForGroup(groupId);\n    for (let index = 0; index < paneDataArray.length - 1; index++) {\n        const { valueMax, valueMin, valueNow } = calculateAriaValues({\n            layout,\n            panesArray: paneDataArray,\n            pivotIndices: [index, index + 1],\n        });\n        const resizeHandleEl = resizeHandleElements[index];\n        if (isHTMLElement(resizeHandleEl)) {\n            const paneData = paneDataArray[index];\n            resizeHandleEl.setAttribute(\"aria-controls\", paneData.id);\n            resizeHandleEl.setAttribute(\"aria-valuemax\", \"\" + Math.round(valueMax));\n            resizeHandleEl.setAttribute(\"aria-valuemin\", \"\" + Math.round(valueMin));\n            resizeHandleEl.setAttribute(\"aria-valuenow\", valueNow != null ? \"\" + Math.round(valueNow) : \"\");\n        }\n    }\n    return () => {\n        resizeHandleElements.forEach((resizeHandleElement) => {\n            resizeHandleElement.removeAttribute(\"aria-controls\");\n            resizeHandleElement.removeAttribute(\"aria-valuemax\");\n            resizeHandleElement.removeAttribute(\"aria-valuemin\");\n            resizeHandleElement.removeAttribute(\"aria-valuenow\");\n        });\n    };\n}\nexport function getResizeHandleElementsForGroup(groupId) {\n    if (!isBrowser)\n        return [];\n    return Array.from(document.querySelectorAll(`[data-pane-resizer-id][data-pane-group-id=\"${groupId}\"]`));\n}\nfunction getPaneGroupElement(id) {\n    if (!isBrowser)\n        return null;\n    const element = document.querySelector(`[data-pane-group][data-pane-group-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nfunction noop() {\n    // do nothing\n}\nexport function getResizeHandlePaneIds(groupId, handleId, panesArray) {\n    const handle = getResizeHandleElement(handleId);\n    const handles = getResizeHandleElementsForGroup(groupId);\n    const index = handle ? handles.indexOf(handle) : -1;\n    const idBefore = panesArray[index]?.id ?? null;\n    const idAfter = panesArray[index + 1]?.id ?? null;\n    return [idBefore, idAfter];\n}\nexport function getResizeHandleElement(id) {\n    if (!isBrowser)\n        return null;\n    const element = document.querySelector(`[data-pane-resizer-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nexport function getResizeHandleElementIndex(groupId, id) {\n    if (!isBrowser)\n        return null;\n    const handles = getResizeHandleElementsForGroup(groupId);\n    const index = handles.findIndex((handle) => handle.getAttribute(\"data-pane-resizer-id\") === id);\n    return index ?? null;\n}\nfunction getPivotIndices(groupId, dragHandleId) {\n    const index = getResizeHandleElementIndex(groupId, dragHandleId);\n    return index != null ? [index, index + 1] : [-1, -1];\n}\nfunction paneDataHelper(paneDataArray, paneData, layout) {\n    const paneConstraintsArray = paneDataArray.map((paneData) => paneData.constraints);\n    const paneIndex = findPaneDataIndex(paneDataArray, paneData);\n    const paneConstraints = paneConstraintsArray[paneIndex];\n    const isLastPane = paneIndex === paneDataArray.length - 1;\n    const pivotIndices = isLastPane ? [paneIndex - 1, paneIndex] : [paneIndex, paneIndex + 1];\n    const paneSize = layout[paneIndex];\n    return {\n        ...paneConstraints,\n        paneSize,\n        pivotIndices,\n    };\n}\nfunction findPaneDataIndex(paneDataArray, paneData) {\n    return paneDataArray.findIndex((prevPaneData) => prevPaneData.id === paneData.id);\n}\n// Layout should be pre-converted into percentages\nfunction callPaneCallbacks(paneArray, layout, paneIdToLastNotifiedSizeMap) {\n    layout.forEach((size, index) => {\n        const paneData = paneArray[index];\n        assert(paneData);\n        const { callbacks, constraints, id: paneId } = paneData;\n        const { collapsedSize = 0, collapsible } = constraints;\n        const lastNotifiedSize = paneIdToLastNotifiedSizeMap[paneId];\n        // invert the logic from below\n        if (!(lastNotifiedSize == null || size !== lastNotifiedSize))\n            return;\n        paneIdToLastNotifiedSizeMap[paneId] = size;\n        const { onCollapse, onExpand, onResize } = callbacks;\n        onResize?.(size, lastNotifiedSize);\n        if (collapsible && (onCollapse || onExpand)) {\n            if (onExpand &&\n                (lastNotifiedSize == null || lastNotifiedSize === collapsedSize) &&\n                size !== collapsedSize) {\n                onExpand();\n            }\n            if (onCollapse &&\n                (lastNotifiedSize == null || lastNotifiedSize !== collapsedSize) &&\n                size === collapsedSize) {\n                onCollapse();\n            }\n        }\n    });\n}\nfunction getUnsafeDefaultLayout({ paneDataArray }) {\n    const layout = Array(paneDataArray.length);\n    const paneConstraintsArray = paneDataArray.map((paneData) => paneData.constraints);\n    let numPanesWithSizes = 0;\n    let remainingSize = 100;\n    // Distribute default sizes first\n    for (let index = 0; index < paneDataArray.length; index++) {\n        const paneConstraints = paneConstraintsArray[index];\n        assert(paneConstraints);\n        const { defaultSize } = paneConstraints;\n        if (defaultSize != null) {\n            numPanesWithSizes++;\n            layout[index] = defaultSize;\n            remainingSize -= defaultSize;\n        }\n    }\n    // Remaining size should be distributed evenly between panes without default sizes\n    for (let index = 0; index < paneDataArray.length; index++) {\n        const paneConstraints = paneConstraintsArray[index];\n        assert(paneConstraints);\n        const { defaultSize } = paneConstraints;\n        if (defaultSize != null) {\n            continue;\n        }\n        const numRemainingPanes = paneDataArray.length - numPanesWithSizes;\n        const size = remainingSize / numRemainingPanes;\n        numPanesWithSizes++;\n        layout[index] = size;\n        remainingSize -= size;\n    }\n    return layout;\n}\n// All units must be in percentages\nfunction validatePaneGroupLayout({ layout: prevLayout, paneConstraints, }) {\n    const nextLayout = [...prevLayout];\n    const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);\n    // Validate layout expectations\n    if (nextLayout.length !== paneConstraints.length) {\n        throw Error(`Invalid ${paneConstraints.length} pane layout: ${nextLayout\n            .map((size) => `${size}%`)\n            .join(\", \")}`);\n    }\n    else if (!areNumbersAlmostEqual(nextLayoutTotalSize, 100)) {\n        for (let index = 0; index < paneConstraints.length; index++) {\n            const unsafeSize = nextLayout[index];\n            assert(unsafeSize != null);\n            const safeSize = (100 / nextLayoutTotalSize) * unsafeSize;\n            nextLayout[index] = safeSize;\n        }\n    }\n    let remainingSize = 0;\n    // First pass: Validate the proposed layout given each pane's constraints\n    for (let index = 0; index < paneConstraints.length; index++) {\n        const unsafeSize = nextLayout[index];\n        assert(unsafeSize != null);\n        const safeSize = resizePane({\n            paneConstraints,\n            paneIndex: index,\n            initialSize: unsafeSize,\n        });\n        if (unsafeSize != safeSize) {\n            remainingSize += unsafeSize - safeSize;\n            nextLayout[index] = safeSize;\n        }\n    }\n    // If there is additional, left over space, assign it to any pane(s) that permits it\n    // (It's not worth taking multiple additional passes to evenly distribute)\n    if (!areNumbersAlmostEqual(remainingSize, 0)) {\n        for (let index = 0; index < paneConstraints.length; index++) {\n            const prevSize = nextLayout[index];\n            assert(prevSize != null);\n            const unsafeSize = prevSize + remainingSize;\n            const safeSize = resizePane({\n                paneConstraints,\n                paneIndex: index,\n                initialSize: unsafeSize,\n            });\n            if (prevSize !== safeSize) {\n                remainingSize -= safeSize - prevSize;\n                nextLayout[index] = safeSize;\n                // Once we've used up the remainder, bail\n                if (areNumbersAlmostEqual(remainingSize, 0)) {\n                    break;\n                }\n            }\n        }\n    }\n    return nextLayout;\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction getDeltaPercentage(e, dragHandleId, dir, initialDragState, keyboardResizeBy) {\n    if (isKeyDown(e)) {\n        const isHorizontal = dir === \"horizontal\";\n        let delta = 0;\n        if (e.shiftKey) {\n            delta = 100;\n        }\n        else if (keyboardResizeBy != null) {\n            delta = keyboardResizeBy;\n        }\n        else {\n            delta = 10;\n        }\n        let movement = 0;\n        switch (e.key) {\n            case \"ArrowDown\":\n                movement = isHorizontal ? 0 : delta;\n                break;\n            case \"ArrowLeft\":\n                movement = isHorizontal ? -delta : 0;\n                break;\n            case \"ArrowRight\":\n                movement = isHorizontal ? delta : 0;\n                break;\n            case \"ArrowUp\":\n                movement = isHorizontal ? 0 : -delta;\n                break;\n            case \"End\":\n                movement = 100;\n                break;\n            case \"Home\":\n                movement = -100;\n                break;\n        }\n        return movement;\n    }\n    else {\n        if (initialDragState == null)\n            return 0;\n        return getDragOffsetPercentage(e, dragHandleId, dir, initialDragState);\n    }\n}\nfunction getDragOffsetPercentage(e, dragHandleId, dir, initialDragState) {\n    const isHorizontal = dir === \"horizontal\";\n    const handleElement = getResizeHandleElement(dragHandleId);\n    assert(handleElement);\n    const groupId = handleElement.getAttribute(\"data-pane-group-id\");\n    assert(groupId);\n    const { initialCursorPosition } = initialDragState;\n    const cursorPosition = getResizeEventCursorPosition(dir, e);\n    const groupElement = getPaneGroupElement(groupId);\n    assert(groupElement);\n    const groupRect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n    const offsetPixels = cursorPosition - initialCursorPosition;\n    const offsetPercentage = (offsetPixels / groupSizeInPixels) * 100;\n    return offsetPercentage;\n}\nfunction getResizeEventCursorPosition(dir, e) {\n    const isHorizontal = dir === \"horizontal\";\n    if (isMouseEvent(e)) {\n        return isHorizontal ? e.clientX : e.clientY;\n    }\n    else if (isTouchEvent(e)) {\n        const firstTouch = e.touches[0];\n        assert(firstTouch);\n        return isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n    }\n    else {\n        throw Error(`Unsupported event type \"${e.type}\"`);\n    }\n}\n","import { createPaneForge } from \"../internal/paneforge.js\";\nimport { getContext, hasContext, setContext } from \"svelte\";\nimport { removeUndefined, getOptionUpdater } from \"../internal/utils/index.js\";\nconst PF_GROUP_CTX = Symbol(\"PF_GROUP_CTX\");\nexport function setCtx(props) {\n    const paneForge = createPaneForge(removeUndefined(props));\n    const updateOption = getOptionUpdater(paneForge.options);\n    const ctxValue = { ...paneForge, updateOption };\n    setContext(PF_GROUP_CTX, ctxValue);\n    return ctxValue;\n}\nexport function getCtx(componentName) {\n    if (!hasContext(PF_GROUP_CTX)) {\n        throw new Error(`${componentName} components must be rendered with a <PaneGroup> container`);\n    }\n    return getContext(PF_GROUP_CTX);\n}\n","<script>import { setCtx } from \"./ctx.js\";\nimport {} from \"../internal/utils/index.js\";\nimport { defaultStorage } from \"../internal/paneforge.js\";\nexport let autoSaveId = null;\nexport let direction;\nexport let id = null;\nexport let keyboardResizeBy = null;\nexport let onLayoutChange = null;\nexport let storage = defaultStorage;\nexport let el = void 0;\nexport let paneGroup = void 0;\nlet styleFromProps = void 0;\nexport { styleFromProps as style };\nconst {\n  states: { paneGroupStyle, paneGroupSelectors, groupId },\n  methods: { setLayout, getLayout },\n  updateOption\n} = setCtx({\n  autoSaveId,\n  direction,\n  id,\n  keyboardResizeBy,\n  onLayout: onLayoutChange,\n  storage\n});\n$:\n  updateOption(\"autoSaveId\", autoSaveId);\n$:\n  updateOption(\"direction\", direction);\n$:\n  updateOption(\"id\", id);\n$:\n  updateOption(\"keyboardResizeBy\", keyboardResizeBy);\n$:\n  updateOption(\"onLayout\", onLayoutChange);\n$:\n  updateOption(\"storage\", storage);\npaneGroup = {\n  getLayout,\n  setLayout,\n  getId: () => $groupId\n};\n$:\n  style = $paneGroupStyle + (styleFromProps ?? \"\");\n</script>\n\n<div bind:this={el} id={$groupId} {...$paneGroupSelectors} {style} {...$$restProps}>\n\t<slot />\n</div>\n","<script>import { generateId } from \"../internal/utils/index.js\";\nimport { onMount } from \"svelte\";\nimport { getCtx } from \"./ctx.js\";\nexport let collapsedSize = void 0;\nexport let collapsible = void 0;\nexport let defaultSize = void 0;\nexport let maxSize = void 0;\nexport let minSize = void 0;\nexport let onCollapse = void 0;\nexport let onExpand = void 0;\nexport let onResize = void 0;\nexport let order = void 0;\nexport let el = void 0;\nexport let pane = void 0;\nlet idFromProps = void 0;\nexport { idFromProps as id };\nlet styleFromProps = void 0;\nexport { styleFromProps as style };\nconst {\n  methods: {\n    getPaneStyle,\n    registerPane,\n    unregisterPane,\n    collapsePane,\n    expandPane,\n    getSize,\n    isCollapsed,\n    isExpanded,\n    resizePane\n  },\n  states: { groupId }\n} = getCtx(\"Pane\");\nconst paneId = generateId(idFromProps);\nlet paneData;\n$:\n  paneData = {\n    callbacks: {\n      onCollapse,\n      onExpand,\n      onResize\n    },\n    constraints: {\n      collapsedSize,\n      collapsible,\n      defaultSize,\n      maxSize,\n      minSize\n    },\n    id: paneId,\n    idIsFromProps: idFromProps !== void 0,\n    order\n  };\npane = {\n  collapse: () => {\n    collapsePane(paneData);\n  },\n  expand: () => expandPane(paneData),\n  getSize: () => getSize(paneData),\n  isCollapsed: () => isCollapsed(paneData),\n  isExpanded: () => isExpanded(paneData),\n  resize: (size) => resizePane(paneData, size),\n  getId: () => paneId\n};\nonMount(() => {\n  registerPane(paneData);\n  return () => {\n    unregisterPane(paneData);\n  };\n});\n$:\n  style = $getPaneStyle(paneData, defaultSize) + (styleFromProps ?? \"\");\n$:\n  attrs = {\n    \"data-pane\": \"\",\n    \"data-pane-id\": paneId,\n    \"data-pane-group-id\": $groupId\n  };\n</script>\n\n<div bind:this={el} {style} {...attrs} {...$$restProps}>\n\t<slot />\n</div>\n","import { chain } from \"../internal/utils/chain.js\";\nimport { addEventListener } from \"../internal/utils/event.js\";\n/**\n * A Svelte action that adds resize handle functionality to an element.\n * This action is used to handle the dragging of a resize handle.\n */\nexport function resizeHandleAction(node, params) {\n    let unsub = () => { };\n    function update(params) {\n        unsub();\n        const { disabled, resizeHandler, isDragging, stopDragging, onDragging = undefined } = params;\n        if (disabled || resizeHandler === null || !isDragging)\n            return;\n        const onMove = (event) => {\n            resizeHandler(event);\n        };\n        const onMouseLeave = (event) => {\n            resizeHandler(event);\n        };\n        const stopDraggingAndBlur = () => {\n            node.blur();\n            stopDragging();\n            if (onDragging) {\n                onDragging(false);\n            }\n        };\n        unsub = chain(addEventListener(document.body, \"contextmenu\", stopDraggingAndBlur), addEventListener(document.body, \"mousemove\", onMove), addEventListener(document.body, \"touchmove\", onMove, { passive: false }), addEventListener(document.body, \"mouseleave\", onMouseLeave), addEventListener(window, \"mouseup\", stopDraggingAndBlur), addEventListener(window, \"touchend\", stopDraggingAndBlur));\n    }\n    update(params);\n    return {\n        update,\n        onDestroy() {\n            unsub();\n        },\n    };\n}\n","<script>import {\n  getResizeHandleElementIndex,\n  getResizeHandleElementsForGroup\n} from \"../internal/paneforge.js\";\nimport { generateId, getCursorStyle, styleToString } from \"../internal/utils/index.js\";\nimport { onMount } from \"svelte\";\nimport { getCtx } from \"./ctx.js\";\nimport { resizeHandleAction } from \"./pane-resizer.js\";\nexport let disabled = false;\nexport let onDraggingChange = void 0;\nexport let tabIndex = 0;\nexport let el = null;\nexport let idFromProps = void 0;\nexport { idFromProps as id };\nexport let styleFromProps = void 0;\nexport { styleFromProps as style };\nconst {\n  methods: { registerResizeHandle, startDragging, stopDragging },\n  states: { direction, dragState, groupId }\n} = getCtx(\"PaneResizer\");\nconst resizeHandleId = generateId(idFromProps);\n$:\n  isDragging = $dragState?.dragHandleId === resizeHandleId;\nlet isFocused = false;\nlet resizeHandler = null;\nfunction stopDraggingAndBlur() {\n  const element = el;\n  if (!element)\n    return;\n  element.blur();\n  stopDragging();\n  onDraggingChange?.(false);\n}\nonMount(() => {\n  if (disabled) {\n    resizeHandler = null;\n  } else {\n    resizeHandler = registerResizeHandle(resizeHandleId);\n  }\n});\n$:\n  if (disabled) {\n    resizeHandler = null;\n  } else {\n    resizeHandler = registerResizeHandle(resizeHandleId);\n  }\nfunction handleKeydown(event) {\n  if (disabled || !resizeHandler || event.defaultPrevented)\n    return;\n  const resizeKeys = [\"ArrowDown\", \"ArrowLeft\", \"ArrowRight\", \"ArrowUp\", \"End\", \"Home\"];\n  if (resizeKeys.includes(event.key)) {\n    event.preventDefault();\n    resizeHandler(event);\n    return;\n  }\n  if (event.key !== \"F6\")\n    return;\n  event.preventDefault();\n  const handles = getResizeHandleElementsForGroup($groupId);\n  const index = getResizeHandleElementIndex($groupId, resizeHandleId);\n  if (index === null)\n    return;\n  const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n  const nextHandle = handles[nextIndex];\n  nextHandle.focus();\n}\n$:\n  style = styleToString({\n    cursor: getCursorStyle($direction),\n    \"touch-action\": \"none\",\n    \"user-select\": \"none\",\n    \"-webkit-user-select\": \"none\",\n    \"-webkit-touch-callout\": \"none\"\n  }) + styleFromProps;\n$:\n  attrs = {\n    \"data-direction\": $direction,\n    \"data-pane-group-id\": $groupId,\n    \"data-active\": isDragging ? \"pointer\" : isFocused ? \"keyboard\" : void 0,\n    \"data-enabled\": !disabled,\n    \"data-pane-resizer-id\": resizeHandleId,\n    \"data-pane-resizer\": \"\"\n  };\n</script>\n\n<!-- svelte-ignore a11y-no-noninteractive-element-interactions -->\n<!-- eslint-disable-next-line svelte/valid-compile -->\n<!-- svelte-ignore a11y-no-noninteractive-tabindex -->\n<div\n\tbind:this={el}\n\trole=\"separator\"\n\t{style}\n\tuse:resizeHandleAction={{\n\t\tdisabled,\n\t\tresizeHandler,\n\t\tstopDragging,\n\t\tisDragging,\n\t\tonDragging: onDraggingChange,\n\t}}\n\ton:keydown={handleKeydown}\n\ton:blur={() => (isFocused = false)}\n\ton:focus={() => (isFocused = true)}\n\ton:mousedown={(e) => {\n\t\te.preventDefault();\n\t\tstartDragging(resizeHandleId, e);\n\t\tonDraggingChange?.(true);\n\t}}\n\ton:mouseup={stopDraggingAndBlur}\n\ton:touchcancel={stopDraggingAndBlur}\n\ton:touchend={stopDraggingAndBlur}\n\ton:touchstart={(e) => {\n\t\te.preventDefault();\n\t\tstartDragging(resizeHandleId, e);\n\t\tonDraggingChange?.(true);\n\t}}\n\ttabindex={tabIndex}\n\t{...attrs}\n\t{...$$restProps}\n>\n\t<slot />\n</div>\n","<script lang=\"ts\">\n\texport let className = 'size-4';\n</script>\n\n<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\" class={className}>\n\t<path\n\t\tfill-rule=\"evenodd\"\n\t\td=\"M5.625 1.5H9a3.75 3.75 0 0 1 3.75 3.75v1.875c0 1.036.84 1.875 1.875 1.875H16.5a3.75 3.75 0 0 1 3.75 3.75v7.875c0 1.035-.84 1.875-1.875 1.875H5.625a1.875 1.875 0 0 1-1.875-1.875V3.375c0-1.036.84-1.875 1.875-1.875Zm6.905 9.97a.75.75 0 0 0-1.06 0l-3 3a.75.75 0 1 0 1.06 1.06l1.72-1.72V18a.75.75 0 0 0 1.5 0v-4.19l1.72 1.72a.75.75 0 1 0 1.06-1.06l-3-3Z\"\n\t\tclip-rule=\"evenodd\"\n\t/>\n\t<path\n\t\td=\"M14.25 5.25a5.23 5.23 0 0 0-1.279-3.434 9.768 9.768 0 0 1 6.963 6.963A5.23 5.23 0 0 0 16.5 7.5h-1.875a.375.375 0 0 1-.375-.375V5.25Z\"\n\t/>\n</svg>\n","<script lang=\"ts\">\n\texport let className = 'size-4';\n</script>\n\n<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\" class={className}>\n\t<path d=\"M12 9a3.75 3.75 0 1 0 0 7.5A3.75 3.75 0 0 0 12 9Z\" />\n\t<path\n\t\tfill-rule=\"evenodd\"\n\t\td=\"M9.344 3.071a49.52 49.52 0 0 1 5.312 0c.967.052 1.83.585 2.332 1.39l.821 1.317c.24.383.645.643 1.11.71.386.054.77.113 1.152.177 1.432.239 2.429 1.493 2.429 2.909V18a3 3 0 0 1-3 3h-15a3 3 0 0 1-3-3V9.574c0-1.416.997-2.67 2.429-2.909.382-.064.766-.123 1.151-.178a1.56 1.56 0 0 0 1.11-.71l.822-1.315a2.942 2.942 0 0 1 2.332-1.39ZM6.75 12.75a5.25 5.25 0 1 1 10.5 0 5.25 5.25 0 0 1-10.5 0Zm12-1.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5Z\"\n\t\tclip-rule=\"evenodd\"\n\t/>\n</svg>\n"],"names":["safeOnDestroy","fn","onDestroy","derivedWithUnsubscribe","stores","unsubscribers","onUnsubscribe","cb","unsubscribe","derivedStore","derived","$storeValues","args","unsub","clientEffect","isBrowser","returned","toWritableStores","properties","result","key","propertyKey","value","writable","getOptionUpdater","options","store","styleToString","style","str","currentState","element","getCursorStyle","state","resetGlobalCursorStyle","setGlobalCursorStyle","computePaneFlexBoxStyle","defaultSize","dragState","layout","paneData","paneIndex","precision","size","flexGrow","calculateAriaValues","panesArray","pivotIndices","currentMinSize","currentMaxSize","totalMinSize","totalMaxSize","firstIndex","i","constraints","maxSize","minSize","valueMax","valueMin","valueNow","generateId","idFromProps","nanoid","LOCAL_STORAGE_DEBOUNCE_INTERVAL","PRECISION","initializeStorage","storageObject","name","err","getPaneGroupKey","autoSaveId","getPaneKey","panes","pane","id","idIsFromProps","order","loadSerializedPaneGroupState","storage","paneGroupKey","serialized","parsed","loadPaneGroupState","paneKey","savePaneGroupState","paneSizesBeforeCollapse","sizes","error","debounceMap","debounce","callback","durationMs","timeoutId","updateStorageValues","paneDataArrayStore","paneSizeBeforeCollapseStore","$paneDataArray","get","debouncedSave","clonedPaneDataArray","$paneSizeBeforeCollapse","clonedPaneSizesBeforeCollapse","removeUndefined","obj","chain","callbacks","addEventListener","target","event","handler","events","_event","areNumbersAlmostEqual","actual","expected","fractionDigits","compareNumbersWithTolerance","roundedActual","roundTo","roundedExpected","areArraysEqual","arrA","arrB","index","decimals","assert","expectedCondition","message","resizePane","paneConstraintsArray","initialSize","paneConstraints","collapsedSize","collapsible","newSize","getAdjustedSizeForCollapsible","halfwayPoint","adjustLayoutByDelta","delta","prevLayout","trigger","nextLayout","firstPivotIndex","secondPivotIndex","deltaApplied","prevSize","localDelta","increment","maxAvailableDelta","minAbsDelta","deltaRemaining","unsafeSize","safeSize","pivotIndex","totalSize","total","isHTMLElement","isKeyDown","isMouseEvent","isTouchEvent","defaultStorage","defaultProps","createPaneForge","props","withDefaults","direction","keyboardResizeBy","onLayout","groupId","paneDataArray","paneDataArrayChanged","paneIdToLastNotifiedSizeMap","paneSizeBeforeCollapseMap","prevDelta","$groupId","$layout","updateResizeHandleAriaValues","onMount","setResizeHandlerEventListeners","$autoSaveId","$storage","collapsePane","$prevLayout","paneSize","paneDataHelper","curr","findPaneDataIndex","$onLayout","callPaneCallbacks","getPaneSize","getPaneStyle","$dragState","isPaneExpanded","registerPane","newArr","paneA","paneB","orderA","orderB","$paneDataArrayChanged","unsafeLayout","getUnsafeDefaultLayout","validatePaneGroupLayout","registerResizeHandle","dragHandleId","$direction","$keyboardResizeBy","initialLayout","getPivotIndices","getDeltaPercentage","isHorizontal","layoutChanged","unsafePaneSize","paneConstraintsArr","startDragging","handleElement","getResizeHandleElement","initialCursorPosition","getResizeEventCursorPosition","stopDragging","unregisterPane","isPaneCollapsed","expandPane","prevPaneSize","baseSize","paneGroupStyle","paneGroupSelectors","paneGroupAttrs","$style","$selectors","unsubHandlers","getResizeHandleElementsForGroup","handle","handleId","noop","idBefore","idAfter","getResizeHandlePaneIds","unsubListener","e","setLayout","newLayout","getLayout","resizeHandleElements","resizeHandleEl","resizeHandleElement","getPaneGroupElement","handles","_a","_b","getResizeHandleElementIndex","prevPaneData","paneArray","paneId","lastNotifiedSize","onCollapse","onExpand","onResize","numPanesWithSizes","remainingSize","numRemainingPanes","nextLayoutTotalSize","accumulated","current","dir","initialDragState","movement","getDragOffsetPercentage","cursorPosition","groupElement","groupRect","groupSizeInPixels","firstTouch","PF_GROUP_CTX","setCtx","paneForge","updateOption","ctxValue","setContext","getCtx","componentName","hasContext","getContext","ctx","insert_hydration","div","anchor","$$props","onLayoutChange","el","paneGroup","styleFromProps","$$value","$paneGroupStyle","div_levels","getSize","isCollapsed","isExpanded","$$invalidate","$getPaneStyle","attrs","resizeHandleAction","node","params","update","disabled","resizeHandler","isDragging","onDragging","onMove","onMouseLeave","stopDraggingAndBlur","onDraggingChange","tabIndex","resizeHandleId","isFocused","handleKeydown","nextIndex","blur_handler","focus_handler","svg","append_hydration","path0","path1","className"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]}