{"version":3,"file":"Dl8uL88t.js","sources":["../../../../../../node_modules/yaml/browser/dist/schema/common/map.js","../../../../../../node_modules/yaml/browser/dist/schema/common/seq.js","../../../../../../node_modules/yaml/browser/dist/schema/common/string.js","../../../../../../node_modules/yaml/browser/dist/schema/common/null.js","../../../../../../node_modules/yaml/browser/dist/schema/core/bool.js","../../../../../../node_modules/yaml/browser/dist/stringify/stringifyNumber.js","../../../../../../node_modules/yaml/browser/dist/schema/core/float.js","../../../../../../node_modules/yaml/browser/dist/schema/core/int.js","../../../../../../node_modules/yaml/browser/dist/schema/core/schema.js","../../../../../../node_modules/yaml/browser/dist/schema/json/schema.js","../../../../../../node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js","../../../../../../node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js","../../../../../../node_modules/yaml/browser/dist/schema/yaml-1.1/float.js","../../../../../../node_modules/yaml/browser/dist/schema/yaml-1.1/int.js","../../../../../../node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js","../../../../../../node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js","../../../../../../node_modules/yaml/browser/dist/schema/tags.js","../../../../../../node_modules/yaml/browser/dist/schema/Schema.js","../../../../../../node_modules/yaml/browser/dist/stringify/stringifyDocument.js","../../../../../../node_modules/yaml/browser/dist/doc/Document.js","../../../../../../node_modules/yaml/browser/dist/errors.js","../../../../../../node_modules/yaml/browser/dist/compose/resolve-props.js","../../../../../../node_modules/yaml/browser/dist/compose/util-contains-newline.js","../../../../../../node_modules/yaml/browser/dist/compose/util-flow-indent-check.js","../../../../../../node_modules/yaml/browser/dist/compose/util-map-includes.js","../../../../../../node_modules/yaml/browser/dist/compose/resolve-block-map.js","../../../../../../node_modules/yaml/browser/dist/compose/resolve-block-seq.js","../../../../../../node_modules/yaml/browser/dist/compose/resolve-end.js","../../../../../../node_modules/yaml/browser/dist/compose/resolve-flow-collection.js","../../../../../../node_modules/yaml/browser/dist/compose/compose-collection.js","../../../../../../node_modules/yaml/browser/dist/compose/resolve-block-scalar.js","../../../../../../node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js","../../../../../../node_modules/yaml/browser/dist/compose/compose-scalar.js","../../../../../../node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js","../../../../../../node_modules/yaml/browser/dist/compose/compose-node.js","../../../../../../node_modules/yaml/browser/dist/compose/compose-doc.js","../../../../../../node_modules/yaml/browser/dist/compose/composer.js","../../../../../../node_modules/yaml/browser/dist/parse/line-counter.js","../../../../../../node_modules/yaml/browser/dist/parse/parser.js","../../../../../../node_modules/yaml/browser/dist/public-api.js","../../../../../../src/lib/apis/index.ts"],"sourcesContent":["import { isMap } from '../../nodes/identity.js';\nimport { YAMLMap } from '../../nodes/YAMLMap.js';\n\nconst map = {\n    collection: 'map',\n    default: true,\n    nodeClass: YAMLMap,\n    tag: 'tag:yaml.org,2002:map',\n    resolve(map, onError) {\n        if (!isMap(map))\n            onError('Expected a mapping for this tag');\n        return map;\n    },\n    createNode: (schema, obj, ctx) => YAMLMap.from(schema, obj, ctx)\n};\n\nexport { map };\n","import { isSeq } from '../../nodes/identity.js';\nimport { YAMLSeq } from '../../nodes/YAMLSeq.js';\n\nconst seq = {\n    collection: 'seq',\n    default: true,\n    nodeClass: YAMLSeq,\n    tag: 'tag:yaml.org,2002:seq',\n    resolve(seq, onError) {\n        if (!isSeq(seq))\n            onError('Expected a sequence for this tag');\n        return seq;\n    },\n    createNode: (schema, obj, ctx) => YAMLSeq.from(schema, obj, ctx)\n};\n\nexport { seq };\n","import { stringifyString } from '../../stringify/stringifyString.js';\n\nconst string = {\n    identify: value => typeof value === 'string',\n    default: true,\n    tag: 'tag:yaml.org,2002:str',\n    resolve: str => str,\n    stringify(item, ctx, onComment, onChompKeep) {\n        ctx = Object.assign({ actualString: true }, ctx);\n        return stringifyString(item, ctx, onComment, onChompKeep);\n    }\n};\n\nexport { string };\n","import { Scalar } from '../../nodes/Scalar.js';\n\nconst nullTag = {\n    identify: value => value == null,\n    createNode: () => new Scalar(null),\n    default: true,\n    tag: 'tag:yaml.org,2002:null',\n    test: /^(?:~|[Nn]ull|NULL)?$/,\n    resolve: () => new Scalar(null),\n    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)\n        ? source\n        : ctx.options.nullStr\n};\n\nexport { nullTag };\n","import { Scalar } from '../../nodes/Scalar.js';\n\nconst boolTag = {\n    identify: value => typeof value === 'boolean',\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n    resolve: str => new Scalar(str[0] === 't' || str[0] === 'T'),\n    stringify({ source, value }, ctx) {\n        if (source && boolTag.test.test(source)) {\n            const sv = source[0] === 't' || source[0] === 'T';\n            if (value === sv)\n                return source;\n        }\n        return value ? ctx.options.trueStr : ctx.options.falseStr;\n    }\n};\n\nexport { boolTag };\n","function stringifyNumber({ format, minFractionDigits, tag, value }) {\n    if (typeof value === 'bigint')\n        return String(value);\n    const num = typeof value === 'number' ? value : Number(value);\n    if (!isFinite(num))\n        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';\n    let n = JSON.stringify(value);\n    if (!format &&\n        minFractionDigits &&\n        (!tag || tag === 'tag:yaml.org,2002:float') &&\n        /^\\d/.test(n)) {\n        let i = n.indexOf('.');\n        if (i < 0) {\n            i = n.length;\n            n += '.';\n        }\n        let d = minFractionDigits - (n.length - i - 1);\n        while (d-- > 0)\n            n += '0';\n    }\n    return n;\n}\n\nexport { stringifyNumber };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF)|\\.nan|\\.NaN|\\.NAN)$/,\n    resolve: str => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n    resolve: str => parseFloat(str),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+\\.[0-9]*)$/,\n    resolve(str) {\n        const node = new Scalar(parseFloat(str));\n        const dot = str.indexOf('.');\n        if (dot !== -1 && str[str.length - 1] === '0')\n            node.minFractionDigits = str.length - dot - 1;\n        return node;\n    },\n    stringify: stringifyNumber\n};\n\nexport { float, floatExp, floatNaN };\n","import { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nconst intResolve = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value) && value >= 0)\n        return prefix + value.toString(radix);\n    return stringifyNumber(node);\n}\nconst intOct = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^0o[0-7]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),\n    stringify: node => intStringify(node, 8, '0o')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber\n};\nconst intHex = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^0x[0-9a-fA-F]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexport { int, intHex, intOct };\n","import { map } from '../common/map.js';\nimport { nullTag } from '../common/null.js';\nimport { seq } from '../common/seq.js';\nimport { string } from '../common/string.js';\nimport { boolTag } from './bool.js';\nimport { floatNaN, floatExp, float } from './float.js';\nimport { intOct, int, intHex } from './int.js';\n\nconst schema = [\n    map,\n    seq,\n    string,\n    nullTag,\n    boolTag,\n    intOct,\n    int,\n    intHex,\n    floatNaN,\n    floatExp,\n    float\n];\n\nexport { schema };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { map } from '../common/map.js';\nimport { seq } from '../common/seq.js';\n\nfunction intIdentify(value) {\n    return typeof value === 'bigint' || Number.isInteger(value);\n}\nconst stringifyJSON = ({ value }) => JSON.stringify(value);\nconst jsonScalars = [\n    {\n        identify: value => typeof value === 'string',\n        default: true,\n        tag: 'tag:yaml.org,2002:str',\n        resolve: str => str,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => value == null,\n        createNode: () => new Scalar(null),\n        default: true,\n        tag: 'tag:yaml.org,2002:null',\n        test: /^null$/,\n        resolve: () => null,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => typeof value === 'boolean',\n        default: true,\n        tag: 'tag:yaml.org,2002:bool',\n        test: /^true$|^false$/,\n        resolve: str => str === 'true',\n        stringify: stringifyJSON\n    },\n    {\n        identify: intIdentify,\n        default: true,\n        tag: 'tag:yaml.org,2002:int',\n        test: /^-?(?:0|[1-9][0-9]*)$/,\n        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),\n        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)\n    },\n    {\n        identify: value => typeof value === 'number',\n        default: true,\n        tag: 'tag:yaml.org,2002:float',\n        test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n        resolve: str => parseFloat(str),\n        stringify: stringifyJSON\n    }\n];\nconst jsonError = {\n    default: true,\n    tag: '',\n    test: /^/,\n    resolve(str, onError) {\n        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n        return str;\n    }\n};\nconst schema = [map, seq].concat(jsonScalars, jsonError);\n\nexport { schema };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyString } from '../../stringify/stringifyString.js';\n\nconst binary = {\n    identify: value => value instanceof Uint8Array, // Buffer inherits from Uint8Array\n    default: false,\n    tag: 'tag:yaml.org,2002:binary',\n    /**\n     * Returns a Buffer in node and an Uint8Array in browsers\n     *\n     * To use the resulting buffer as an image, you'll want to do something like:\n     *\n     *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n     *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n     */\n    resolve(src, onError) {\n        if (typeof atob === 'function') {\n            // On IE 11, atob() can't handle newlines\n            const str = atob(src.replace(/[\\n\\r]/g, ''));\n            const buffer = new Uint8Array(str.length);\n            for (let i = 0; i < str.length; ++i)\n                buffer[i] = str.charCodeAt(i);\n            return buffer;\n        }\n        else {\n            onError('This environment does not support reading binary tags; either Buffer or atob is required');\n            return src;\n        }\n    },\n    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {\n        if (!value)\n            return '';\n        const buf = value; // checked earlier by binary.identify()\n        let str;\n        if (typeof btoa === 'function') {\n            let s = '';\n            for (let i = 0; i < buf.length; ++i)\n                s += String.fromCharCode(buf[i]);\n            str = btoa(s);\n        }\n        else {\n            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n        }\n        if (!type)\n            type = Scalar.BLOCK_LITERAL;\n        if (type !== Scalar.QUOTE_DOUBLE) {\n            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);\n            const n = Math.ceil(str.length / lineWidth);\n            const lines = new Array(n);\n            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n                lines[i] = str.substr(o, lineWidth);\n            }\n            str = lines.join(type === Scalar.BLOCK_LITERAL ? '\\n' : ' ');\n        }\n        return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);\n    }\n};\n\nexport { binary };\n","import { Scalar } from '../../nodes/Scalar.js';\n\nfunction boolStringify({ value, source }, ctx) {\n    const boolObj = value ? trueTag : falseTag;\n    if (source && boolObj.test.test(source))\n        return source;\n    return value ? ctx.options.trueStr : ctx.options.falseStr;\n}\nconst trueTag = {\n    identify: value => value === true,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n    resolve: () => new Scalar(true),\n    stringify: boolStringify\n};\nconst falseTag = {\n    identify: value => value === false,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,\n    resolve: () => new Scalar(false),\n    stringify: boolStringify\n};\n\nexport { falseTag, trueTag };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF)|\\.nan|\\.NaN|\\.NAN)$/,\n    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n    resolve: (str) => parseFloat(str.replace(/_/g, '')),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:[0-9][0-9_]*)?\\.[0-9_]*$/,\n    resolve(str) {\n        const node = new Scalar(parseFloat(str.replace(/_/g, '')));\n        const dot = str.indexOf('.');\n        if (dot !== -1) {\n            const f = str.substring(dot + 1).replace(/_/g, '');\n            if (f[f.length - 1] === '0')\n                node.minFractionDigits = f.length;\n        }\n        return node;\n    },\n    stringify: stringifyNumber\n};\n\nexport { float, floatExp, floatNaN };\n","import { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nfunction intResolve(str, offset, radix, { intAsBigInt }) {\n    const sign = str[0];\n    if (sign === '-' || sign === '+')\n        offset += 1;\n    str = str.substring(offset).replace(/_/g, '');\n    if (intAsBigInt) {\n        switch (radix) {\n            case 2:\n                str = `0b${str}`;\n                break;\n            case 8:\n                str = `0o${str}`;\n                break;\n            case 16:\n                str = `0x${str}`;\n                break;\n        }\n        const n = BigInt(str);\n        return sign === '-' ? BigInt(-1) * n : n;\n    }\n    const n = parseInt(str, radix);\n    return sign === '-' ? -1 * n : n;\n}\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value)) {\n        const str = value.toString(radix);\n        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n    }\n    return stringifyNumber(node);\n}\nconst intBin = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'BIN',\n    test: /^[-+]?0b[0-1_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),\n    stringify: node => intStringify(node, 2, '0b')\n};\nconst intOct = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^[-+]?0[0-7_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),\n    stringify: node => intStringify(node, 8, '0')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9][0-9_]*$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber\n};\nconst intHex = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^[-+]?0x[0-9a-fA-F_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexport { int, intBin, intHex, intOct };\n","import { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\n/** Internal types handle bigint as number, because TS can't figure it out. */\nfunction parseSexagesimal(str, asBigInt) {\n    const sign = str[0];\n    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;\n    const num = (n) => asBigInt ? BigInt(n) : Number(n);\n    const res = parts\n        .replace(/_/g, '')\n        .split(':')\n        .reduce((res, p) => res * num(60) + num(p), num(0));\n    return (sign === '-' ? num(-1) * res : res);\n}\n/**\n * hhhh:mm:ss.sss\n *\n * Internal types handle bigint as number, because TS can't figure it out.\n */\nfunction stringifySexagesimal(node) {\n    let { value } = node;\n    let num = (n) => n;\n    if (typeof value === 'bigint')\n        num = n => BigInt(n);\n    else if (isNaN(value) || !isFinite(value))\n        return stringifyNumber(node);\n    let sign = '';\n    if (value < 0) {\n        sign = '-';\n        value *= num(-1);\n    }\n    const _60 = num(60);\n    const parts = [value % _60]; // seconds, including ms\n    if (value < 60) {\n        parts.unshift(0); // at least one : is required\n    }\n    else {\n        value = (value - parts[0]) / _60;\n        parts.unshift(value % _60); // minutes\n        if (value >= 60) {\n            value = (value - parts[0]) / _60;\n            parts.unshift(value); // hours\n        }\n    }\n    return (sign +\n        parts\n            .map(n => String(n).padStart(2, '0'))\n            .join(':')\n            .replace(/000000\\d*$/, '') // % 60 may introduce error\n    );\n}\nconst intTime = {\n    identify: value => typeof value === 'bigint' || Number.isInteger(value),\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,\n    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),\n    stringify: stringifySexagesimal\n};\nconst floatTime = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*$/,\n    resolve: str => parseSexagesimal(str, false),\n    stringify: stringifySexagesimal\n};\nconst timestamp = {\n    identify: value => value instanceof Date,\n    default: true,\n    tag: 'tag:yaml.org,2002:timestamp',\n    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n    // may be omitted altogether, resulting in a date format. In such a case, the time part is\n    // assumed to be 00:00:00Z (start of day, UTC).\n    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n        '(?:' + // time is optional\n        '(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n        '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n        ')?$'),\n    resolve(str) {\n        const match = str.match(timestamp.test);\n        if (!match)\n            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');\n        const [, year, month, day, hour, minute, second] = match.map(Number);\n        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;\n        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);\n        const tz = match[8];\n        if (tz && tz !== 'Z') {\n            let d = parseSexagesimal(tz, false);\n            if (Math.abs(d) < 30)\n                d *= 60;\n            date -= 60000 * d;\n        }\n        return new Date(date);\n    },\n    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\\.000Z$/, '') ?? ''\n};\n\nexport { floatTime, intTime, timestamp };\n","import { map } from '../common/map.js';\nimport { nullTag } from '../common/null.js';\nimport { seq } from '../common/seq.js';\nimport { string } from '../common/string.js';\nimport { binary } from './binary.js';\nimport { trueTag, falseTag } from './bool.js';\nimport { floatNaN, floatExp, float } from './float.js';\nimport { intBin, intOct, int, intHex } from './int.js';\nimport { merge } from './merge.js';\nimport { omap } from './omap.js';\nimport { pairs } from './pairs.js';\nimport { set } from './set.js';\nimport { intTime, floatTime, timestamp } from './timestamp.js';\n\nconst schema = [\n    map,\n    seq,\n    string,\n    nullTag,\n    trueTag,\n    falseTag,\n    intBin,\n    intOct,\n    int,\n    intHex,\n    floatNaN,\n    floatExp,\n    float,\n    binary,\n    merge,\n    omap,\n    pairs,\n    set,\n    intTime,\n    floatTime,\n    timestamp\n];\n\nexport { schema };\n","import { map } from './common/map.js';\nimport { nullTag } from './common/null.js';\nimport { seq } from './common/seq.js';\nimport { string } from './common/string.js';\nimport { boolTag } from './core/bool.js';\nimport { float, floatExp, floatNaN } from './core/float.js';\nimport { int, intHex, intOct } from './core/int.js';\nimport { schema } from './core/schema.js';\nimport { schema as schema$1 } from './json/schema.js';\nimport { binary } from './yaml-1.1/binary.js';\nimport { merge } from './yaml-1.1/merge.js';\nimport { omap } from './yaml-1.1/omap.js';\nimport { pairs } from './yaml-1.1/pairs.js';\nimport { schema as schema$2 } from './yaml-1.1/schema.js';\nimport { set } from './yaml-1.1/set.js';\nimport { timestamp, floatTime, intTime } from './yaml-1.1/timestamp.js';\n\nconst schemas = new Map([\n    ['core', schema],\n    ['failsafe', [map, seq, string]],\n    ['json', schema$1],\n    ['yaml11', schema$2],\n    ['yaml-1.1', schema$2]\n]);\nconst tagsByName = {\n    binary,\n    bool: boolTag,\n    float,\n    floatExp,\n    floatNaN,\n    floatTime,\n    int,\n    intHex,\n    intOct,\n    intTime,\n    map,\n    merge,\n    null: nullTag,\n    omap,\n    pairs,\n    seq,\n    set,\n    timestamp\n};\nconst coreKnownTags = {\n    'tag:yaml.org,2002:binary': binary,\n    'tag:yaml.org,2002:merge': merge,\n    'tag:yaml.org,2002:omap': omap,\n    'tag:yaml.org,2002:pairs': pairs,\n    'tag:yaml.org,2002:set': set,\n    'tag:yaml.org,2002:timestamp': timestamp\n};\nfunction getTags(customTags, schemaName, addMergeTag) {\n    const schemaTags = schemas.get(schemaName);\n    if (schemaTags && !customTags) {\n        return addMergeTag && !schemaTags.includes(merge)\n            ? schemaTags.concat(merge)\n            : schemaTags.slice();\n    }\n    let tags = schemaTags;\n    if (!tags) {\n        if (Array.isArray(customTags))\n            tags = [];\n        else {\n            const keys = Array.from(schemas.keys())\n                .filter(key => key !== 'yaml11')\n                .map(key => JSON.stringify(key))\n                .join(', ');\n            throw new Error(`Unknown schema \"${schemaName}\"; use one of ${keys} or define customTags array`);\n        }\n    }\n    if (Array.isArray(customTags)) {\n        for (const tag of customTags)\n            tags = tags.concat(tag);\n    }\n    else if (typeof customTags === 'function') {\n        tags = customTags(tags.slice());\n    }\n    if (addMergeTag)\n        tags = tags.concat(merge);\n    return tags.reduce((tags, tag) => {\n        const tagObj = typeof tag === 'string' ? tagsByName[tag] : tag;\n        if (!tagObj) {\n            const tagName = JSON.stringify(tag);\n            const keys = Object.keys(tagsByName)\n                .map(key => JSON.stringify(key))\n                .join(', ');\n            throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);\n        }\n        if (!tags.includes(tagObj))\n            tags.push(tagObj);\n        return tags;\n    }, []);\n}\n\nexport { coreKnownTags, getTags };\n","import { MAP, SCALAR, SEQ } from '../nodes/identity.js';\nimport { map } from './common/map.js';\nimport { seq } from './common/seq.js';\nimport { string } from './common/string.js';\nimport { getTags, coreKnownTags } from './tags.js';\n\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\nclass Schema {\n    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {\n        this.compat = Array.isArray(compat)\n            ? getTags(compat, 'compat')\n            : compat\n                ? getTags(null, compat)\n                : null;\n        this.name = (typeof schema === 'string' && schema) || 'core';\n        this.knownTags = resolveKnownTags ? coreKnownTags : {};\n        this.tags = getTags(customTags, this.name, merge);\n        this.toStringOptions = toStringDefaults ?? null;\n        Object.defineProperty(this, MAP, { value: map });\n        Object.defineProperty(this, SCALAR, { value: string });\n        Object.defineProperty(this, SEQ, { value: seq });\n        // Used by createMap()\n        this.sortMapEntries =\n            typeof sortMapEntries === 'function'\n                ? sortMapEntries\n                : sortMapEntries === true\n                    ? sortMapEntriesByKey\n                    : null;\n    }\n    clone() {\n        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));\n        copy.tags = this.tags.slice();\n        return copy;\n    }\n}\n\nexport { Schema };\n","import { isNode } from '../nodes/identity.js';\nimport { createStringifyContext, stringify } from './stringify.js';\nimport { indentComment, lineComment } from './stringifyComment.js';\n\nfunction stringifyDocument(doc, options) {\n    const lines = [];\n    let hasDirectives = options.directives === true;\n    if (options.directives !== false && doc.directives) {\n        const dir = doc.directives.toString(doc);\n        if (dir) {\n            lines.push(dir);\n            hasDirectives = true;\n        }\n        else if (doc.directives.docStart)\n            hasDirectives = true;\n    }\n    if (hasDirectives)\n        lines.push('---');\n    const ctx = createStringifyContext(doc, options);\n    const { commentString } = ctx.options;\n    if (doc.commentBefore) {\n        if (lines.length !== 1)\n            lines.unshift('');\n        const cs = commentString(doc.commentBefore);\n        lines.unshift(indentComment(cs, ''));\n    }\n    let chompKeep = false;\n    let contentComment = null;\n    if (doc.contents) {\n        if (isNode(doc.contents)) {\n            if (doc.contents.spaceBefore && hasDirectives)\n                lines.push('');\n            if (doc.contents.commentBefore) {\n                const cs = commentString(doc.contents.commentBefore);\n                lines.push(indentComment(cs, ''));\n            }\n            // top-level block scalars need to be indented if followed by a comment\n            ctx.forceBlockIndent = !!doc.comment;\n            contentComment = doc.contents.comment;\n        }\n        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);\n        let body = stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);\n        if (contentComment)\n            body += lineComment(body, '', commentString(contentComment));\n        if ((body[0] === '|' || body[0] === '>') &&\n            lines[lines.length - 1] === '---') {\n            // Top-level block scalars with a preceding doc marker ought to use the\n            // same line for their header.\n            lines[lines.length - 1] = `--- ${body}`;\n        }\n        else\n            lines.push(body);\n    }\n    else {\n        lines.push(stringify(doc.contents, ctx));\n    }\n    if (doc.directives?.docEnd) {\n        if (doc.comment) {\n            const cs = commentString(doc.comment);\n            if (cs.includes('\\n')) {\n                lines.push('...');\n                lines.push(indentComment(cs, ''));\n            }\n            else {\n                lines.push(`... ${cs}`);\n            }\n        }\n        else {\n            lines.push('...');\n        }\n    }\n    else {\n        let dc = doc.comment;\n        if (dc && chompKeep)\n            dc = dc.replace(/^\\n+/, '');\n        if (dc) {\n            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')\n                lines.push('');\n            lines.push(indentComment(commentString(dc), ''));\n        }\n    }\n    return lines.join('\\n') + '\\n';\n}\n\nexport { stringifyDocument };\n","import { Alias } from '../nodes/Alias.js';\nimport { isEmptyPath, collectionFromPath } from '../nodes/Collection.js';\nimport { NODE_TYPE, DOC, isNode, isCollection, isScalar } from '../nodes/identity.js';\nimport { Pair } from '../nodes/Pair.js';\nimport { toJS } from '../nodes/toJS.js';\nimport { Schema } from '../schema/Schema.js';\nimport { stringifyDocument } from '../stringify/stringifyDocument.js';\nimport { anchorNames, findNewAnchor, createNodeAnchors } from './anchors.js';\nimport { applyReviver } from './applyReviver.js';\nimport { createNode } from './createNode.js';\nimport { Directives } from './directives.js';\n\nclass Document {\n    constructor(value, replacer, options) {\n        /** A comment before this Document */\n        this.commentBefore = null;\n        /** A comment immediately after this Document */\n        this.comment = null;\n        /** Errors encountered during parsing. */\n        this.errors = [];\n        /** Warnings encountered during parsing. */\n        this.warnings = [];\n        Object.defineProperty(this, NODE_TYPE, { value: DOC });\n        let _replacer = null;\n        if (typeof replacer === 'function' || Array.isArray(replacer)) {\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const opt = Object.assign({\n            intAsBigInt: false,\n            keepSourceTokens: false,\n            logLevel: 'warn',\n            prettyErrors: true,\n            strict: true,\n            stringKeys: false,\n            uniqueKeys: true,\n            version: '1.2'\n        }, options);\n        this.options = opt;\n        let { version } = opt;\n        if (options?._directives) {\n            this.directives = options._directives.atDocument();\n            if (this.directives.yaml.explicit)\n                version = this.directives.yaml.version;\n        }\n        else\n            this.directives = new Directives({ version });\n        this.setSchema(version, options);\n        // @ts-expect-error We can't really know that this matches Contents.\n        this.contents =\n            value === undefined ? null : this.createNode(value, _replacer, options);\n    }\n    /**\n     * Create a deep copy of this Document and its contents.\n     *\n     * Custom Node values that inherit from `Object` still refer to their original instances.\n     */\n    clone() {\n        const copy = Object.create(Document.prototype, {\n            [NODE_TYPE]: { value: DOC }\n        });\n        copy.commentBefore = this.commentBefore;\n        copy.comment = this.comment;\n        copy.errors = this.errors.slice();\n        copy.warnings = this.warnings.slice();\n        copy.options = Object.assign({}, this.options);\n        if (this.directives)\n            copy.directives = this.directives.clone();\n        copy.schema = this.schema.clone();\n        // @ts-expect-error We can't really know that this matches Contents.\n        copy.contents = isNode(this.contents)\n            ? this.contents.clone(copy.schema)\n            : this.contents;\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** Adds a value to the document. */\n    add(value) {\n        if (assertCollection(this.contents))\n            this.contents.add(value);\n    }\n    /** Adds a value to the document. */\n    addIn(path, value) {\n        if (assertCollection(this.contents))\n            this.contents.addIn(path, value);\n    }\n    /**\n     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.\n     *\n     * If `node` already has an anchor, `name` is ignored.\n     * Otherwise, the `node.anchor` value will be set to `name`,\n     * or if an anchor with that name is already present in the document,\n     * `name` will be used as a prefix for a new unique anchor.\n     * If `name` is undefined, the generated anchor will use 'a' as a prefix.\n     */\n    createAlias(node, name) {\n        if (!node.anchor) {\n            const prev = anchorNames(this);\n            node.anchor =\n                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n                !name || prev.has(name) ? findNewAnchor(name || 'a', prev) : name;\n        }\n        return new Alias(node.anchor);\n    }\n    createNode(value, replacer, options) {\n        let _replacer = undefined;\n        if (typeof replacer === 'function') {\n            value = replacer.call({ '': value }, '', value);\n            _replacer = replacer;\n        }\n        else if (Array.isArray(replacer)) {\n            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;\n            const asStr = replacer.filter(keyToStr).map(String);\n            if (asStr.length > 0)\n                replacer = replacer.concat(asStr);\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};\n        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, \n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        anchorPrefix || 'a');\n        const ctx = {\n            aliasDuplicateObjects: aliasDuplicateObjects ?? true,\n            keepUndefined: keepUndefined ?? false,\n            onAnchor,\n            onTagObj,\n            replacer: _replacer,\n            schema: this.schema,\n            sourceObjects\n        };\n        const node = createNode(value, tag, ctx);\n        if (flow && isCollection(node))\n            node.flow = true;\n        setAnchors();\n        return node;\n    }\n    /**\n     * Convert a key and a value into a `Pair` using the current schema,\n     * recursively wrapping all values as `Scalar` or `Collection` nodes.\n     */\n    createPair(key, value, options = {}) {\n        const k = this.createNode(key, null, options);\n        const v = this.createNode(value, null, options);\n        return new Pair(k, v);\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        return assertCollection(this.contents) ? this.contents.delete(key) : false;\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        if (isEmptyPath(path)) {\n            if (this.contents == null)\n                return false;\n            // @ts-expect-error Presumed impossible if Strict extends false\n            this.contents = null;\n            return true;\n        }\n        return assertCollection(this.contents)\n            ? this.contents.deleteIn(path)\n            : false;\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    get(key, keepScalar) {\n        return isCollection(this.contents)\n            ? this.contents.get(key, keepScalar)\n            : undefined;\n    }\n    /**\n     * Returns item at `path`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        if (isEmptyPath(path))\n            return !keepScalar && isScalar(this.contents)\n                ? this.contents.value\n                : this.contents;\n        return isCollection(this.contents)\n            ? this.contents.getIn(path, keepScalar)\n            : undefined;\n    }\n    /**\n     * Checks if the document includes a value with the key `key`.\n     */\n    has(key) {\n        return isCollection(this.contents) ? this.contents.has(key) : false;\n    }\n    /**\n     * Checks if the document includes a value at `path`.\n     */\n    hasIn(path) {\n        if (isEmptyPath(path))\n            return this.contents !== undefined;\n        return isCollection(this.contents) ? this.contents.hasIn(path) : false;\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    set(key, value) {\n        if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = collectionFromPath(this.schema, [key], value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.set(key, value);\n        }\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        if (isEmptyPath(path)) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = value;\n        }\n        else if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = collectionFromPath(this.schema, Array.from(path), value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.setIn(path, value);\n        }\n    }\n    /**\n     * Change the YAML version and schema used by the document.\n     * A `null` version disables support for directives, explicit tags, anchors, and aliases.\n     * It also requires the `schema` option to be given as a `Schema` instance value.\n     *\n     * Overrides all previously set schema options.\n     */\n    setSchema(version, options = {}) {\n        if (typeof version === 'number')\n            version = String(version);\n        let opt;\n        switch (version) {\n            case '1.1':\n                if (this.directives)\n                    this.directives.yaml.version = '1.1';\n                else\n                    this.directives = new Directives({ version: '1.1' });\n                opt = { resolveKnownTags: false, schema: 'yaml-1.1' };\n                break;\n            case '1.2':\n            case 'next':\n                if (this.directives)\n                    this.directives.yaml.version = version;\n                else\n                    this.directives = new Directives({ version });\n                opt = { resolveKnownTags: true, schema: 'core' };\n                break;\n            case null:\n                if (this.directives)\n                    delete this.directives;\n                opt = null;\n                break;\n            default: {\n                const sv = JSON.stringify(version);\n                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);\n            }\n        }\n        // Not using `instanceof Schema` to allow for duck typing\n        if (options.schema instanceof Object)\n            this.schema = options.schema;\n        else if (opt)\n            this.schema = new Schema(Object.assign(opt, options));\n        else\n            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);\n    }\n    // json & jsonArg are only used from toJSON()\n    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        const ctx = {\n            anchors: new Map(),\n            doc: this,\n            keep: !json,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100\n        };\n        const res = toJS(this.contents, jsonArg ?? '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n    /**\n     * A JSON representation of the document `contents`.\n     *\n     * @param jsonArg Used by `JSON.stringify` to indicate the array index or\n     *   property name.\n     */\n    toJSON(jsonArg, onAnchor) {\n        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });\n    }\n    /** A YAML representation of the document. */\n    toString(options = {}) {\n        if (this.errors.length > 0)\n            throw new Error('Document with errors cannot be stringified');\n        if ('indent' in options &&\n            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {\n            const s = JSON.stringify(options.indent);\n            throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n        }\n        return stringifyDocument(this, options);\n    }\n}\nfunction assertCollection(contents) {\n    if (isCollection(contents))\n        return true;\n    throw new Error('Expected a YAML collection as document contents');\n}\n\nexport { Document };\n","class YAMLError extends Error {\n    constructor(name, pos, code, message) {\n        super();\n        this.name = name;\n        this.code = code;\n        this.message = message;\n        this.pos = pos;\n    }\n}\nclass YAMLParseError extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLParseError', pos, code, message);\n    }\n}\nclass YAMLWarning extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLWarning', pos, code, message);\n    }\n}\nconst prettifyError = (src, lc) => (error) => {\n    if (error.pos[0] === -1)\n        return;\n    error.linePos = error.pos.map(pos => lc.linePos(pos));\n    const { line, col } = error.linePos[0];\n    error.message += ` at line ${line}, column ${col}`;\n    let ci = col - 1;\n    let lineStr = src\n        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])\n        .replace(/[\\n\\r]+$/, '');\n    // Trim to max 80 chars, keeping col position near the middle\n    if (ci >= 60 && lineStr.length > 80) {\n        const trimStart = Math.min(ci - 39, lineStr.length - 79);\n        lineStr = '…' + lineStr.substring(trimStart);\n        ci -= trimStart - 1;\n    }\n    if (lineStr.length > 80)\n        lineStr = lineStr.substring(0, 79) + '…';\n    // Include previous line in context if pointing at line start\n    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {\n        // Regexp won't match if start is trimmed\n        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);\n        if (prev.length > 80)\n            prev = prev.substring(0, 79) + '…\\n';\n        lineStr = prev + lineStr;\n    }\n    if (/[^ ]/.test(lineStr)) {\n        let count = 1;\n        const end = error.linePos[1];\n        if (end && end.line === line && end.col > col) {\n            count = Math.max(1, Math.min(end.col - col, 80 - ci));\n        }\n        const pointer = ' '.repeat(ci) + '^'.repeat(count);\n        error.message += `:\\n\\n${lineStr}\\n${pointer}\\n`;\n    }\n};\n\nexport { YAMLError, YAMLParseError, YAMLWarning, prettifyError };\n","function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {\n    let spaceBefore = false;\n    let atNewline = startOnNewline;\n    let hasSpace = startOnNewline;\n    let comment = '';\n    let commentSep = '';\n    let hasNewline = false;\n    let reqSpace = false;\n    let tab = null;\n    let anchor = null;\n    let tag = null;\n    let newlineAfterProp = null;\n    let comma = null;\n    let found = null;\n    let start = null;\n    for (const token of tokens) {\n        if (reqSpace) {\n            if (token.type !== 'space' &&\n                token.type !== 'newline' &&\n                token.type !== 'comma')\n                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n            reqSpace = false;\n        }\n        if (tab) {\n            if (atNewline && token.type !== 'comment' && token.type !== 'newline') {\n                onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n            }\n            tab = null;\n        }\n        switch (token.type) {\n            case 'space':\n                // At the doc level, tabs at line start may be parsed\n                // as leading white space rather than indentation.\n                // In a flow collection, only the parser handles indent.\n                if (!flow &&\n                    (indicator !== 'doc-start' || next?.type !== 'flow-collection') &&\n                    token.source.includes('\\t')) {\n                    tab = token;\n                }\n                hasSpace = true;\n                break;\n            case 'comment': {\n                if (!hasSpace)\n                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                const cb = token.source.substring(1) || ' ';\n                if (!comment)\n                    comment = cb;\n                else\n                    comment += commentSep + cb;\n                commentSep = '';\n                atNewline = false;\n                break;\n            }\n            case 'newline':\n                if (atNewline) {\n                    if (comment)\n                        comment += token.source;\n                    else if (!found || indicator !== 'seq-item-ind')\n                        spaceBefore = true;\n                }\n                else\n                    commentSep += token.source;\n                atNewline = true;\n                hasNewline = true;\n                if (anchor || tag)\n                    newlineAfterProp = token;\n                hasSpace = true;\n                break;\n            case 'anchor':\n                if (anchor)\n                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');\n                if (token.source.endsWith(':'))\n                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);\n                anchor = token;\n                if (start === null)\n                    start = token.offset;\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            case 'tag': {\n                if (tag)\n                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');\n                tag = token;\n                if (start === null)\n                    start = token.offset;\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            }\n            case indicator:\n                // Could here handle preceding comments differently\n                if (anchor || tag)\n                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);\n                if (found)\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);\n                found = token;\n                atNewline =\n                    indicator === 'seq-item-ind' || indicator === 'explicit-key-ind';\n                hasSpace = false;\n                break;\n            case 'comma':\n                if (flow) {\n                    if (comma)\n                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);\n                    comma = token;\n                    atNewline = false;\n                    hasSpace = false;\n                    break;\n                }\n            // else fallthrough\n            default:\n                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);\n                atNewline = false;\n                hasSpace = false;\n        }\n    }\n    const last = tokens[tokens.length - 1];\n    const end = last ? last.offset + last.source.length : offset;\n    if (reqSpace &&\n        next &&\n        next.type !== 'space' &&\n        next.type !== 'newline' &&\n        next.type !== 'comma' &&\n        (next.type !== 'scalar' || next.source !== '')) {\n        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n    }\n    if (tab &&\n        ((atNewline && tab.indent <= parentIndent) ||\n            next?.type === 'block-map' ||\n            next?.type === 'block-seq'))\n        onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n    return {\n        comma,\n        found,\n        spaceBefore,\n        comment,\n        hasNewline,\n        anchor,\n        tag,\n        newlineAfterProp,\n        end,\n        start: start ?? end\n    };\n}\n\nexport { resolveProps };\n","function containsNewline(key) {\n    if (!key)\n        return null;\n    switch (key.type) {\n        case 'alias':\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            if (key.source.includes('\\n'))\n                return true;\n            if (key.end)\n                for (const st of key.end)\n                    if (st.type === 'newline')\n                        return true;\n            return false;\n        case 'flow-collection':\n            for (const it of key.items) {\n                for (const st of it.start)\n                    if (st.type === 'newline')\n                        return true;\n                if (it.sep)\n                    for (const st of it.sep)\n                        if (st.type === 'newline')\n                            return true;\n                if (containsNewline(it.key) || containsNewline(it.value))\n                    return true;\n            }\n            return false;\n        default:\n            return true;\n    }\n}\n\nexport { containsNewline };\n","import { containsNewline } from './util-contains-newline.js';\n\nfunction flowIndentCheck(indent, fc, onError) {\n    if (fc?.type === 'flow-collection') {\n        const end = fc.end[0];\n        if (end.indent === indent &&\n            (end.source === ']' || end.source === '}') &&\n            containsNewline(fc)) {\n            const msg = 'Flow end indicator should be more indented than parent';\n            onError(end, 'BAD_INDENT', msg, true);\n        }\n    }\n}\n\nexport { flowIndentCheck };\n","import { isScalar } from '../nodes/identity.js';\n\nfunction mapIncludes(ctx, items, search) {\n    const { uniqueKeys } = ctx.options;\n    if (uniqueKeys === false)\n        return false;\n    const isEqual = typeof uniqueKeys === 'function'\n        ? uniqueKeys\n        : (a, b) => a === b || (isScalar(a) && isScalar(b) && a.value === b.value);\n    return items.some(pair => isEqual(pair.key, search));\n}\n\nexport { mapIncludes };\n","import { Pair } from '../nodes/Pair.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { resolveProps } from './resolve-props.js';\nimport { containsNewline } from './util-contains-newline.js';\nimport { flowIndentCheck } from './util-flow-indent-check.js';\nimport { mapIncludes } from './util-map-includes.js';\n\nconst startColMsg = 'All mapping items must start at the same column';\nfunction resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLMap;\n    const map = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    let offset = bm.offset;\n    let commentEnd = null;\n    for (const collItem of bm.items) {\n        const { start, key, sep, value } = collItem;\n        // key properties\n        const keyProps = resolveProps(start, {\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            parentIndent: bm.indent,\n            startOnNewline: true\n        });\n        const implicitKey = !keyProps.found;\n        if (implicitKey) {\n            if (key) {\n                if (key.type === 'block-seq')\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');\n                else if ('indent' in key && key.indent !== bm.indent)\n                    onError(offset, 'BAD_INDENT', startColMsg);\n            }\n            if (!keyProps.anchor && !keyProps.tag && !sep) {\n                commentEnd = keyProps.end;\n                if (keyProps.comment) {\n                    if (map.comment)\n                        map.comment += '\\n' + keyProps.comment;\n                    else\n                        map.comment = keyProps.comment;\n                }\n                continue;\n            }\n            if (keyProps.newlineAfterProp || containsNewline(key)) {\n                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');\n            }\n        }\n        else if (keyProps.found?.indent !== bm.indent) {\n            onError(offset, 'BAD_INDENT', startColMsg);\n        }\n        // key value\n        ctx.atKey = true;\n        const keyStart = keyProps.end;\n        const keyNode = key\n            ? composeNode(ctx, key, keyProps, onError)\n            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);\n        if (ctx.schema.compat)\n            flowIndentCheck(bm.indent, key, onError);\n        ctx.atKey = false;\n        if (mapIncludes(ctx, map.items, keyNode))\n            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n        // value properties\n        const valueProps = resolveProps(sep ?? [], {\n            indicator: 'map-value-ind',\n            next: value,\n            offset: keyNode.range[2],\n            onError,\n            parentIndent: bm.indent,\n            startOnNewline: !key || key.type === 'block-scalar'\n        });\n        offset = valueProps.end;\n        if (valueProps.found) {\n            if (implicitKey) {\n                if (value?.type === 'block-map' && !valueProps.hasNewline)\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');\n                if (ctx.options.strict &&\n                    keyProps.start < valueProps.found.offset - 1024)\n                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);\n            if (ctx.schema.compat)\n                flowIndentCheck(bm.indent, value, onError);\n            offset = valueNode.range[2];\n            const pair = new Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n        else {\n            // key with no value\n            if (implicitKey)\n                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');\n            if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair(keyNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n    }\n    if (commentEnd && commentEnd < offset)\n        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');\n    map.range = [bm.offset, offset, commentEnd ?? offset];\n    return map;\n}\n\nexport { resolveBlockMap };\n","import { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveProps } from './resolve-props.js';\nimport { flowIndentCheck } from './util-flow-indent-check.js';\n\nfunction resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLSeq;\n    const seq = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    if (ctx.atKey)\n        ctx.atKey = false;\n    let offset = bs.offset;\n    let commentEnd = null;\n    for (const { start, value } of bs.items) {\n        const props = resolveProps(start, {\n            indicator: 'seq-item-ind',\n            next: value,\n            offset,\n            onError,\n            parentIndent: bs.indent,\n            startOnNewline: true\n        });\n        if (!props.found) {\n            if (props.anchor || props.tag || value) {\n                if (value && value.type === 'block-seq')\n                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');\n                else\n                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');\n            }\n            else {\n                commentEnd = props.end;\n                if (props.comment)\n                    seq.comment = props.comment;\n                continue;\n            }\n        }\n        const node = value\n            ? composeNode(ctx, value, props, onError)\n            : composeEmptyNode(ctx, props.end, start, null, props, onError);\n        if (ctx.schema.compat)\n            flowIndentCheck(bs.indent, value, onError);\n        offset = node.range[2];\n        seq.items.push(node);\n    }\n    seq.range = [bs.offset, offset, commentEnd ?? offset];\n    return seq;\n}\n\nexport { resolveBlockSeq };\n","function resolveEnd(end, offset, reqSpace, onError) {\n    let comment = '';\n    if (end) {\n        let hasSpace = false;\n        let sep = '';\n        for (const token of end) {\n            const { source, type } = token;\n            switch (type) {\n                case 'space':\n                    hasSpace = true;\n                    break;\n                case 'comment': {\n                    if (reqSpace && !hasSpace)\n                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                    const cb = source.substring(1) || ' ';\n                    if (!comment)\n                        comment = cb;\n                    else\n                        comment += sep + cb;\n                    sep = '';\n                    break;\n                }\n                case 'newline':\n                    if (comment)\n                        sep += source;\n                    hasSpace = true;\n                    break;\n                default:\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);\n            }\n            offset += source.length;\n        }\n    }\n    return { comment, offset };\n}\n\nexport { resolveEnd };\n","import { isPair } from '../nodes/identity.js';\nimport { Pair } from '../nodes/Pair.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { resolveProps } from './resolve-props.js';\nimport { containsNewline } from './util-contains-newline.js';\nimport { mapIncludes } from './util-map-includes.js';\n\nconst blockMsg = 'Block collections are not allowed within flow collections';\nconst isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');\nfunction resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {\n    const isMap = fc.start.source === '{';\n    const fcName = isMap ? 'flow map' : 'flow sequence';\n    const NodeClass = (tag?.nodeClass ?? (isMap ? YAMLMap : YAMLSeq));\n    const coll = new NodeClass(ctx.schema);\n    coll.flow = true;\n    const atRoot = ctx.atRoot;\n    if (atRoot)\n        ctx.atRoot = false;\n    if (ctx.atKey)\n        ctx.atKey = false;\n    let offset = fc.offset + fc.start.source.length;\n    for (let i = 0; i < fc.items.length; ++i) {\n        const collItem = fc.items[i];\n        const { start, key, sep, value } = collItem;\n        const props = resolveProps(start, {\n            flow: fcName,\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            parentIndent: fc.indent,\n            startOnNewline: false\n        });\n        if (!props.found) {\n            if (!props.anchor && !props.tag && !sep && !value) {\n                if (i === 0 && props.comma)\n                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n                else if (i < fc.items.length - 1)\n                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);\n                if (props.comment) {\n                    if (coll.comment)\n                        coll.comment += '\\n' + props.comment;\n                    else\n                        coll.comment = props.comment;\n                }\n                offset = props.end;\n                continue;\n            }\n            if (!isMap && ctx.options.strict && containsNewline(key))\n                onError(key, // checked by containsNewline()\n                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n        }\n        if (i === 0) {\n            if (props.comma)\n                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n        }\n        else {\n            if (!props.comma)\n                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);\n            if (props.comment) {\n                let prevItemComment = '';\n                loop: for (const st of start) {\n                    switch (st.type) {\n                        case 'comma':\n                        case 'space':\n                            break;\n                        case 'comment':\n                            prevItemComment = st.source.substring(1);\n                            break loop;\n                        default:\n                            break loop;\n                    }\n                }\n                if (prevItemComment) {\n                    let prev = coll.items[coll.items.length - 1];\n                    if (isPair(prev))\n                        prev = prev.value ?? prev.key;\n                    if (prev.comment)\n                        prev.comment += '\\n' + prevItemComment;\n                    else\n                        prev.comment = prevItemComment;\n                    props.comment = props.comment.substring(prevItemComment.length + 1);\n                }\n            }\n        }\n        if (!isMap && !sep && !props.found) {\n            // item is a value in a seq\n            // → key & sep are empty, start does not include ? or :\n            const valueNode = value\n                ? composeNode(ctx, value, props, onError)\n                : composeEmptyNode(ctx, props.end, sep, null, props, onError);\n            coll.items.push(valueNode);\n            offset = valueNode.range[2];\n            if (isBlock(value))\n                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n        }\n        else {\n            // item is a key+value pair\n            // key value\n            ctx.atKey = true;\n            const keyStart = props.end;\n            const keyNode = key\n                ? composeNode(ctx, key, props, onError)\n                : composeEmptyNode(ctx, keyStart, start, null, props, onError);\n            if (isBlock(key))\n                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            ctx.atKey = false;\n            // value properties\n            const valueProps = resolveProps(sep ?? [], {\n                flow: fcName,\n                indicator: 'map-value-ind',\n                next: value,\n                offset: keyNode.range[2],\n                onError,\n                parentIndent: fc.indent,\n                startOnNewline: false\n            });\n            if (valueProps.found) {\n                if (!isMap && !props.found && ctx.options.strict) {\n                    if (sep)\n                        for (const st of sep) {\n                            if (st === valueProps.found)\n                                break;\n                            if (st.type === 'newline') {\n                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n                                break;\n                            }\n                        }\n                    if (props.start < valueProps.found.offset - 1024)\n                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');\n                }\n            }\n            else if (value) {\n                if ('source' in value && value.source && value.source[0] === ':')\n                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);\n                else\n                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : valueProps.found\n                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)\n                    : null;\n            if (valueNode) {\n                if (isBlock(value))\n                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            }\n            else if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            if (isMap) {\n                const map = coll;\n                if (mapIncludes(ctx, map.items, keyNode))\n                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n                map.items.push(pair);\n            }\n            else {\n                const map = new YAMLMap(ctx.schema);\n                map.flow = true;\n                map.items.push(pair);\n                const endRange = (valueNode ?? keyNode).range;\n                map.range = [keyNode.range[0], endRange[1], endRange[2]];\n                coll.items.push(map);\n            }\n            offset = valueNode ? valueNode.range[2] : valueProps.end;\n        }\n    }\n    const expectedEnd = isMap ? '}' : ']';\n    const [ce, ...ee] = fc.end;\n    let cePos = offset;\n    if (ce && ce.source === expectedEnd)\n        cePos = ce.offset + ce.source.length;\n    else {\n        const name = fcName[0].toUpperCase() + fcName.substring(1);\n        const msg = atRoot\n            ? `${name} must end with a ${expectedEnd}`\n            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;\n        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);\n        if (ce && ce.source.length !== 1)\n            ee.unshift(ce);\n    }\n    if (ee.length > 0) {\n        const end = resolveEnd(ee, cePos, ctx.options.strict, onError);\n        if (end.comment) {\n            if (coll.comment)\n                coll.comment += '\\n' + end.comment;\n            else\n                coll.comment = end.comment;\n        }\n        coll.range = [fc.offset, cePos, end.offset];\n    }\n    else {\n        coll.range = [fc.offset, cePos, cePos];\n    }\n    return coll;\n}\n\nexport { resolveFlowCollection };\n","import { isNode } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveBlockMap } from './resolve-block-map.js';\nimport { resolveBlockSeq } from './resolve-block-seq.js';\nimport { resolveFlowCollection } from './resolve-flow-collection.js';\n\nfunction resolveCollection(CN, ctx, token, onError, tagName, tag) {\n    const coll = token.type === 'block-map'\n        ? resolveBlockMap(CN, ctx, token, onError, tag)\n        : token.type === 'block-seq'\n            ? resolveBlockSeq(CN, ctx, token, onError, tag)\n            : resolveFlowCollection(CN, ctx, token, onError, tag);\n    const Coll = coll.constructor;\n    // If we got a tagName matching the class, or the tag name is '!',\n    // then use the tagName from the node class used to create it.\n    if (tagName === '!' || tagName === Coll.tagName) {\n        coll.tag = Coll.tagName;\n        return coll;\n    }\n    if (tagName)\n        coll.tag = tagName;\n    return coll;\n}\nfunction composeCollection(CN, ctx, token, props, onError) {\n    const tagToken = props.tag;\n    const tagName = !tagToken\n        ? null\n        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\n    if (token.type === 'block-seq') {\n        const { anchor, newlineAfterProp: nl } = props;\n        const lastProp = anchor && tagToken\n            ? anchor.offset > tagToken.offset\n                ? anchor\n                : tagToken\n            : (anchor ?? tagToken);\n        if (lastProp && (!nl || nl.offset < lastProp.offset)) {\n            const message = 'Missing newline after block sequence props';\n            onError(lastProp, 'MISSING_CHAR', message);\n        }\n    }\n    const expType = token.type === 'block-map'\n        ? 'map'\n        : token.type === 'block-seq'\n            ? 'seq'\n            : token.start.source === '{'\n                ? 'map'\n                : 'seq';\n    // shortcut: check if it's a generic YAMLMap or YAMLSeq\n    // before jumping into the custom tag logic.\n    if (!tagToken ||\n        !tagName ||\n        tagName === '!' ||\n        (tagName === YAMLMap.tagName && expType === 'map') ||\n        (tagName === YAMLSeq.tagName && expType === 'seq')) {\n        return resolveCollection(CN, ctx, token, onError, tagName);\n    }\n    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);\n    if (!tag) {\n        const kt = ctx.schema.knownTags[tagName];\n        if (kt && kt.collection === expType) {\n            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));\n            tag = kt;\n        }\n        else {\n            if (kt) {\n                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? 'scalar'}`, true);\n            }\n            else {\n                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\n            }\n            return resolveCollection(CN, ctx, token, onError, tagName);\n        }\n    }\n    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);\n    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;\n    const node = isNode(res)\n        ? res\n        : new Scalar(res);\n    node.range = coll.range;\n    node.tag = tagName;\n    if (tag?.format)\n        node.format = tag.format;\n    return node;\n}\n\nexport { composeCollection };\n","import { Scalar } from '../nodes/Scalar.js';\n\nfunction resolveBlockScalar(ctx, scalar, onError) {\n    const start = scalar.offset;\n    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);\n    if (!header)\n        return { value: '', type: null, comment: '', range: [start, start, start] };\n    const type = header.mode === '>' ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;\n    const lines = scalar.source ? splitLines(scalar.source) : [];\n    // determine the end of content & start of chomping\n    let chompStart = lines.length;\n    for (let i = lines.length - 1; i >= 0; --i) {\n        const content = lines[i][1];\n        if (content === '' || content === '\\r')\n            chompStart = i;\n        else\n            break;\n    }\n    // shortcut for empty contents\n    if (chompStart === 0) {\n        const value = header.chomp === '+' && lines.length > 0\n            ? '\\n'.repeat(Math.max(1, lines.length - 1))\n            : '';\n        let end = start + header.length;\n        if (scalar.source)\n            end += scalar.source.length;\n        return { value, type, comment: header.comment, range: [start, end, end] };\n    }\n    // find the indentation level to trim from start\n    let trimIndent = scalar.indent + header.indent;\n    let offset = scalar.offset + header.length;\n    let contentStart = 0;\n    for (let i = 0; i < chompStart; ++i) {\n        const [indent, content] = lines[i];\n        if (content === '' || content === '\\r') {\n            if (header.indent === 0 && indent.length > trimIndent)\n                trimIndent = indent.length;\n        }\n        else {\n            if (indent.length < trimIndent) {\n                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n                onError(offset + indent.length, 'MISSING_CHAR', message);\n            }\n            if (header.indent === 0)\n                trimIndent = indent.length;\n            contentStart = i;\n            if (trimIndent === 0 && !ctx.atRoot) {\n                const message = 'Block scalar values in collections must be indented';\n                onError(offset, 'BAD_INDENT', message);\n            }\n            break;\n        }\n        offset += indent.length + content.length + 1;\n    }\n    // include trailing more-indented empty lines in content\n    for (let i = lines.length - 1; i >= chompStart; --i) {\n        if (lines[i][0].length > trimIndent)\n            chompStart = i + 1;\n    }\n    let value = '';\n    let sep = '';\n    let prevMoreIndented = false;\n    // leading whitespace is kept intact\n    for (let i = 0; i < contentStart; ++i)\n        value += lines[i][0].slice(trimIndent) + '\\n';\n    for (let i = contentStart; i < chompStart; ++i) {\n        let [indent, content] = lines[i];\n        offset += indent.length + content.length + 1;\n        const crlf = content[content.length - 1] === '\\r';\n        if (crlf)\n            content = content.slice(0, -1);\n        /* istanbul ignore if already caught in lexer */\n        if (content && indent.length < trimIndent) {\n            const src = header.indent\n                ? 'explicit indentation indicator'\n                : 'first line';\n            const message = `Block scalar lines must not be less indented than their ${src}`;\n            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);\n            indent = '';\n        }\n        if (type === Scalar.BLOCK_LITERAL) {\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n        }\n        else if (indent.length > trimIndent || content[0] === '\\t') {\n            // more-indented content within a folded block\n            if (sep === ' ')\n                sep = '\\n';\n            else if (!prevMoreIndented && sep === '\\n')\n                sep = '\\n\\n';\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n            prevMoreIndented = true;\n        }\n        else if (content === '') {\n            // empty line\n            if (sep === '\\n')\n                value += '\\n';\n            else\n                sep = '\\n';\n        }\n        else {\n            value += sep + content;\n            sep = ' ';\n            prevMoreIndented = false;\n        }\n    }\n    switch (header.chomp) {\n        case '-':\n            break;\n        case '+':\n            for (let i = chompStart; i < lines.length; ++i)\n                value += '\\n' + lines[i][0].slice(trimIndent);\n            if (value[value.length - 1] !== '\\n')\n                value += '\\n';\n            break;\n        default:\n            value += '\\n';\n    }\n    const end = start + header.length + scalar.source.length;\n    return { value, type, comment: header.comment, range: [start, end, end] };\n}\nfunction parseBlockScalarHeader({ offset, props }, strict, onError) {\n    /* istanbul ignore if should not happen */\n    if (props[0].type !== 'block-scalar-header') {\n        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');\n        return null;\n    }\n    const { source } = props[0];\n    const mode = source[0];\n    let indent = 0;\n    let chomp = '';\n    let error = -1;\n    for (let i = 1; i < source.length; ++i) {\n        const ch = source[i];\n        if (!chomp && (ch === '-' || ch === '+'))\n            chomp = ch;\n        else {\n            const n = Number(ch);\n            if (!indent && n)\n                indent = n;\n            else if (error === -1)\n                error = offset + i;\n        }\n    }\n    if (error !== -1)\n        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);\n    let hasSpace = false;\n    let comment = '';\n    let length = source.length;\n    for (let i = 1; i < props.length; ++i) {\n        const token = props[i];\n        switch (token.type) {\n            case 'space':\n                hasSpace = true;\n            // fallthrough\n            case 'newline':\n                length += token.source.length;\n                break;\n            case 'comment':\n                if (strict && !hasSpace) {\n                    const message = 'Comments must be separated from other tokens by white space characters';\n                    onError(token, 'MISSING_CHAR', message);\n                }\n                length += token.source.length;\n                comment = token.source.substring(1);\n                break;\n            case 'error':\n                onError(token, 'UNEXPECTED_TOKEN', token.message);\n                length += token.source.length;\n                break;\n            /* istanbul ignore next should not happen */\n            default: {\n                const message = `Unexpected token in block scalar header: ${token.type}`;\n                onError(token, 'UNEXPECTED_TOKEN', message);\n                const ts = token.source;\n                if (ts && typeof ts === 'string')\n                    length += ts.length;\n            }\n        }\n    }\n    return { mode, indent, chomp, comment, length };\n}\n/** @returns Array of lines split up as `[indent, content]` */\nfunction splitLines(source) {\n    const split = source.split(/\\n( *)/);\n    const first = split[0];\n    const m = first.match(/^( *)/);\n    const line0 = m?.[1]\n        ? [m[1], first.slice(m[1].length)]\n        : ['', first];\n    const lines = [line0];\n    for (let i = 1; i < split.length; i += 2)\n        lines.push([split[i], split[i + 1]]);\n    return lines;\n}\n\nexport { resolveBlockScalar };\n","import { Scalar } from '../nodes/Scalar.js';\nimport { resolveEnd } from './resolve-end.js';\n\nfunction resolveFlowScalar(scalar, strict, onError) {\n    const { offset, type, source, end } = scalar;\n    let _type;\n    let value;\n    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);\n    switch (type) {\n        case 'scalar':\n            _type = Scalar.PLAIN;\n            value = plainValue(source, _onError);\n            break;\n        case 'single-quoted-scalar':\n            _type = Scalar.QUOTE_SINGLE;\n            value = singleQuotedValue(source, _onError);\n            break;\n        case 'double-quoted-scalar':\n            _type = Scalar.QUOTE_DOUBLE;\n            value = doubleQuotedValue(source, _onError);\n            break;\n        /* istanbul ignore next should not happen */\n        default:\n            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);\n            return {\n                value: '',\n                type: null,\n                comment: '',\n                range: [offset, offset + source.length, offset + source.length]\n            };\n    }\n    const valueEnd = offset + source.length;\n    const re = resolveEnd(end, valueEnd, strict, onError);\n    return {\n        value,\n        type: _type,\n        comment: re.comment,\n        range: [offset, valueEnd, re.offset]\n    };\n}\nfunction plainValue(source, onError) {\n    let badChar = '';\n    switch (source[0]) {\n        /* istanbul ignore next should not happen */\n        case '\\t':\n            badChar = 'a tab character';\n            break;\n        case ',':\n            badChar = 'flow indicator character ,';\n            break;\n        case '%':\n            badChar = 'directive indicator character %';\n            break;\n        case '|':\n        case '>': {\n            badChar = `block scalar indicator ${source[0]}`;\n            break;\n        }\n        case '@':\n        case '`': {\n            badChar = `reserved character ${source[0]}`;\n            break;\n        }\n    }\n    if (badChar)\n        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);\n    return foldLines(source);\n}\nfunction singleQuotedValue(source, onError) {\n    if (source[source.length - 1] !== \"'\" || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', \"Missing closing 'quote\");\n    return foldLines(source.slice(1, -1)).replace(/''/g, \"'\");\n}\nfunction foldLines(source) {\n    /**\n     * The negative lookbehind here and in the `re` RegExp is to\n     * prevent causing a polynomial search time in certain cases.\n     *\n     * The try-catch is for Safari, which doesn't support this yet:\n     * https://caniuse.com/js-regexp-lookbehind\n     */\n    let first, line;\n    try {\n        first = new RegExp('(.*?)(?<![ \\t])[ \\t]*\\r?\\n', 'sy');\n        line = new RegExp('[ \\t]*(.*?)(?:(?<![ \\t])[ \\t]*)?\\r?\\n', 'sy');\n    }\n    catch {\n        first = /(.*?)[ \\t]*\\r?\\n/sy;\n        line = /[ \\t]*(.*?)[ \\t]*\\r?\\n/sy;\n    }\n    let match = first.exec(source);\n    if (!match)\n        return source;\n    let res = match[1];\n    let sep = ' ';\n    let pos = first.lastIndex;\n    line.lastIndex = pos;\n    while ((match = line.exec(source))) {\n        if (match[1] === '') {\n            if (sep === '\\n')\n                res += sep;\n            else\n                sep = '\\n';\n        }\n        else {\n            res += sep + match[1];\n            sep = ' ';\n        }\n        pos = line.lastIndex;\n    }\n    const last = /[ \\t]*(.*)/sy;\n    last.lastIndex = pos;\n    match = last.exec(source);\n    return res + sep + (match?.[1] ?? '');\n}\nfunction doubleQuotedValue(source, onError) {\n    let res = '';\n    for (let i = 1; i < source.length - 1; ++i) {\n        const ch = source[i];\n        if (ch === '\\r' && source[i + 1] === '\\n')\n            continue;\n        if (ch === '\\n') {\n            const { fold, offset } = foldNewline(source, i);\n            res += fold;\n            i = offset;\n        }\n        else if (ch === '\\\\') {\n            let next = source[++i];\n            const cc = escapeCodes[next];\n            if (cc)\n                res += cc;\n            else if (next === '\\n') {\n                // skip escaped newlines, but still trim the following line\n                next = source[i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === '\\r' && source[i + 1] === '\\n') {\n                // skip escaped CRLF newlines, but still trim the following line\n                next = source[++i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === 'x' || next === 'u' || next === 'U') {\n                const length = { x: 2, u: 4, U: 8 }[next];\n                res += parseCharCode(source, i + 1, length, onError);\n                i += length;\n            }\n            else {\n                const raw = source.substr(i - 1, 2);\n                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n                res += raw;\n            }\n        }\n        else if (ch === ' ' || ch === '\\t') {\n            // trim trailing whitespace\n            const wsStart = i;\n            let next = source[i + 1];\n            while (next === ' ' || next === '\\t')\n                next = source[++i + 1];\n            if (next !== '\\n' && !(next === '\\r' && source[i + 2] === '\\n'))\n                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;\n        }\n        else {\n            res += ch;\n        }\n    }\n    if (source[source.length - 1] !== '\"' || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', 'Missing closing \"quote');\n    return res;\n}\n/**\n * Fold a single newline into a space, multiple newlines to N - 1 newlines.\n * Presumes `source[offset] === '\\n'`\n */\nfunction foldNewline(source, offset) {\n    let fold = '';\n    let ch = source[offset + 1];\n    while (ch === ' ' || ch === '\\t' || ch === '\\n' || ch === '\\r') {\n        if (ch === '\\r' && source[offset + 2] !== '\\n')\n            break;\n        if (ch === '\\n')\n            fold += '\\n';\n        offset += 1;\n        ch = source[offset + 1];\n    }\n    if (!fold)\n        fold = ' ';\n    return { fold, offset };\n}\nconst escapeCodes = {\n    '0': '\\0', // null character\n    a: '\\x07', // bell character\n    b: '\\b', // backspace\n    e: '\\x1b', // escape character\n    f: '\\f', // form feed\n    n: '\\n', // line feed\n    r: '\\r', // carriage return\n    t: '\\t', // horizontal tab\n    v: '\\v', // vertical tab\n    N: '\\u0085', // Unicode next line\n    _: '\\u00a0', // Unicode non-breaking space\n    L: '\\u2028', // Unicode line separator\n    P: '\\u2029', // Unicode paragraph separator\n    ' ': ' ',\n    '\"': '\"',\n    '/': '/',\n    '\\\\': '\\\\',\n    '\\t': '\\t'\n};\nfunction parseCharCode(source, offset, length, onError) {\n    const cc = source.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n    if (isNaN(code)) {\n        const raw = source.substr(offset - 2, length + 2);\n        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n        return raw;\n    }\n    return String.fromCodePoint(code);\n}\n\nexport { resolveFlowScalar };\n","import { isScalar, SCALAR } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { resolveBlockScalar } from './resolve-block-scalar.js';\nimport { resolveFlowScalar } from './resolve-flow-scalar.js';\n\nfunction composeScalar(ctx, token, tagToken, onError) {\n    const { value, type, comment, range } = token.type === 'block-scalar'\n        ? resolveBlockScalar(ctx, token, onError)\n        : resolveFlowScalar(token, ctx.options.strict, onError);\n    const tagName = tagToken\n        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))\n        : null;\n    let tag;\n    if (ctx.options.stringKeys && ctx.atKey) {\n        tag = ctx.schema[SCALAR];\n    }\n    else if (tagName)\n        tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);\n    else if (token.type === 'scalar')\n        tag = findScalarTagByTest(ctx, value, token, onError);\n    else\n        tag = ctx.schema[SCALAR];\n    let scalar;\n    try {\n        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);\n        scalar = isScalar(res) ? res : new Scalar(res);\n    }\n    catch (error) {\n        const msg = error instanceof Error ? error.message : String(error);\n        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);\n        scalar = new Scalar(value);\n    }\n    scalar.range = range;\n    scalar.source = value;\n    if (type)\n        scalar.type = type;\n    if (tagName)\n        scalar.tag = tagName;\n    if (tag.format)\n        scalar.format = tag.format;\n    if (comment)\n        scalar.comment = comment;\n    return scalar;\n}\nfunction findScalarTagByName(schema, value, tagName, tagToken, onError) {\n    if (tagName === '!')\n        return schema[SCALAR]; // non-specific tag\n    const matchWithTest = [];\n    for (const tag of schema.tags) {\n        if (!tag.collection && tag.tag === tagName) {\n            if (tag.default && tag.test)\n                matchWithTest.push(tag);\n            else\n                return tag;\n        }\n    }\n    for (const tag of matchWithTest)\n        if (tag.test?.test(value))\n            return tag;\n    const kt = schema.knownTags[tagName];\n    if (kt && !kt.collection) {\n        // Ensure that the known tag is available for stringifying,\n        // but does not get used by default.\n        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));\n        return kt;\n    }\n    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');\n    return schema[SCALAR];\n}\nfunction findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {\n    const tag = schema.tags.find(tag => (tag.default === true || (atKey && tag.default === 'key')) &&\n        tag.test?.test(value)) || schema[SCALAR];\n    if (schema.compat) {\n        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??\n            schema[SCALAR];\n        if (tag.tag !== compat.tag) {\n            const ts = directives.tagString(tag.tag);\n            const cs = directives.tagString(compat.tag);\n            const msg = `Value may be parsed as either ${ts} or ${cs}`;\n            onError(token, 'TAG_RESOLVE_FAILED', msg, true);\n        }\n    }\n    return tag;\n}\n\nexport { composeScalar };\n","function emptyScalarPosition(offset, before, pos) {\n    if (before) {\n        if (pos === null)\n            pos = before.length;\n        for (let i = pos - 1; i >= 0; --i) {\n            let st = before[i];\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                case 'newline':\n                    offset -= st.source.length;\n                    continue;\n            }\n            // Technically, an empty scalar is immediately after the last non-empty\n            // node, but it's more useful to place it after any whitespace.\n            st = before[++i];\n            while (st?.type === 'space') {\n                offset += st.source.length;\n                st = before[++i];\n            }\n            break;\n        }\n    }\n    return offset;\n}\n\nexport { emptyScalarPosition };\n","import { Alias } from '../nodes/Alias.js';\nimport { isScalar } from '../nodes/identity.js';\nimport { composeCollection } from './compose-collection.js';\nimport { composeScalar } from './compose-scalar.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { emptyScalarPosition } from './util-empty-scalar-position.js';\n\nconst CN = { composeNode, composeEmptyNode };\nfunction composeNode(ctx, token, props, onError) {\n    const atKey = ctx.atKey;\n    const { spaceBefore, comment, anchor, tag } = props;\n    let node;\n    let isSrcToken = true;\n    switch (token.type) {\n        case 'alias':\n            node = composeAlias(ctx, token, onError);\n            if (anchor || tag)\n                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');\n            break;\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'block-scalar':\n            node = composeScalar(ctx, token, tag, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        case 'block-map':\n        case 'block-seq':\n        case 'flow-collection':\n            node = composeCollection(CN, ctx, token, props, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        default: {\n            const message = token.type === 'error'\n                ? token.message\n                : `Unsupported token (type: ${token.type})`;\n            onError(token, 'UNEXPECTED_TOKEN', message);\n            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);\n            isSrcToken = false;\n        }\n    }\n    if (anchor && node.anchor === '')\n        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    if (atKey &&\n        ctx.options.stringKeys &&\n        (!isScalar(node) ||\n            typeof node.value !== 'string' ||\n            (node.tag && node.tag !== 'tag:yaml.org,2002:str'))) {\n        const msg = 'With stringKeys, all keys must be strings';\n        onError(tag ?? token, 'NON_STRING_KEY', msg);\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        if (token.type === 'scalar' && token.source === '')\n            node.comment = comment;\n        else\n            node.commentBefore = comment;\n    }\n    // @ts-expect-error Type checking misses meaning of isSrcToken\n    if (ctx.options.keepSourceTokens && isSrcToken)\n        node.srcToken = token;\n    return node;\n}\nfunction composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {\n    const token = {\n        type: 'scalar',\n        offset: emptyScalarPosition(offset, before, pos),\n        indent: -1,\n        source: ''\n    };\n    const node = composeScalar(ctx, token, tag, onError);\n    if (anchor) {\n        node.anchor = anchor.source.substring(1);\n        if (node.anchor === '')\n            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        node.comment = comment;\n        node.range[2] = end;\n    }\n    return node;\n}\nfunction composeAlias({ options }, { offset, source, end }, onError) {\n    const alias = new Alias(source.substring(1));\n    if (alias.source === '')\n        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');\n    if (alias.source.endsWith(':'))\n        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);\n    const valueEnd = offset + source.length;\n    const re = resolveEnd(end, valueEnd, options.strict, onError);\n    alias.range = [offset, valueEnd, re.offset];\n    if (re.comment)\n        alias.comment = re.comment;\n    return alias;\n}\n\nexport { composeEmptyNode, composeNode };\n","import { Document } from '../doc/Document.js';\nimport { composeNode, composeEmptyNode } from './compose-node.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { resolveProps } from './resolve-props.js';\n\nfunction composeDoc(options, directives, { offset, start, value, end }, onError) {\n    const opts = Object.assign({ _directives: directives }, options);\n    const doc = new Document(undefined, opts);\n    const ctx = {\n        atKey: false,\n        atRoot: true,\n        directives: doc.directives,\n        options: doc.options,\n        schema: doc.schema\n    };\n    const props = resolveProps(start, {\n        indicator: 'doc-start',\n        next: value ?? end?.[0],\n        offset,\n        onError,\n        parentIndent: 0,\n        startOnNewline: true\n    });\n    if (props.found) {\n        doc.directives.docStart = true;\n        if (value &&\n            (value.type === 'block-map' || value.type === 'block-seq') &&\n            !props.hasNewline)\n            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');\n    }\n    // @ts-expect-error If Contents is set, let's trust the user\n    doc.contents = value\n        ? composeNode(ctx, value, props, onError)\n        : composeEmptyNode(ctx, props.end, start, null, props, onError);\n    const contentEnd = doc.contents.range[2];\n    const re = resolveEnd(end, contentEnd, false, onError);\n    if (re.comment)\n        doc.comment = re.comment;\n    doc.range = [offset, contentEnd, re.offset];\n    return doc;\n}\n\nexport { composeDoc };\n","import { Directives } from '../doc/directives.js';\nimport { Document } from '../doc/Document.js';\nimport { YAMLWarning, YAMLParseError } from '../errors.js';\nimport { isCollection, isPair } from '../nodes/identity.js';\nimport { composeDoc } from './compose-doc.js';\nimport { resolveEnd } from './resolve-end.js';\n\nfunction getErrorPos(src) {\n    if (typeof src === 'number')\n        return [src, src + 1];\n    if (Array.isArray(src))\n        return src.length === 2 ? src : [src[0], src[1]];\n    const { offset, source } = src;\n    return [offset, offset + (typeof source === 'string' ? source.length : 1)];\n}\nfunction parsePrelude(prelude) {\n    let comment = '';\n    let atComment = false;\n    let afterEmptyLine = false;\n    for (let i = 0; i < prelude.length; ++i) {\n        const source = prelude[i];\n        switch (source[0]) {\n            case '#':\n                comment +=\n                    (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') +\n                        (source.substring(1) || ' ');\n                atComment = true;\n                afterEmptyLine = false;\n                break;\n            case '%':\n                if (prelude[i + 1]?.[0] !== '#')\n                    i += 1;\n                atComment = false;\n                break;\n            default:\n                // This may be wrong after doc-end, but in that case it doesn't matter\n                if (!atComment)\n                    afterEmptyLine = true;\n                atComment = false;\n        }\n    }\n    return { comment, afterEmptyLine };\n}\n/**\n * Compose a stream of CST nodes into a stream of YAML Documents.\n *\n * ```ts\n * import { Composer, Parser } from 'yaml'\n *\n * const src: string = ...\n * const tokens = new Parser().parse(src)\n * const docs = new Composer().compose(tokens)\n * ```\n */\nclass Composer {\n    constructor(options = {}) {\n        this.doc = null;\n        this.atDirectives = false;\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n        this.onError = (source, code, message, warning) => {\n            const pos = getErrorPos(source);\n            if (warning)\n                this.warnings.push(new YAMLWarning(pos, code, message));\n            else\n                this.errors.push(new YAMLParseError(pos, code, message));\n        };\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.directives = new Directives({ version: options.version || '1.2' });\n        this.options = options;\n    }\n    decorate(doc, afterDoc) {\n        const { comment, afterEmptyLine } = parsePrelude(this.prelude);\n        //console.log({ dc: doc.comment, prelude, comment })\n        if (comment) {\n            const dc = doc.contents;\n            if (afterDoc) {\n                doc.comment = doc.comment ? `${doc.comment}\\n${comment}` : comment;\n            }\n            else if (afterEmptyLine || doc.directives.docStart || !dc) {\n                doc.commentBefore = comment;\n            }\n            else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {\n                let it = dc.items[0];\n                if (isPair(it))\n                    it = it.key;\n                const cb = it.commentBefore;\n                it.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n            else {\n                const cb = dc.commentBefore;\n                dc.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n        }\n        if (afterDoc) {\n            Array.prototype.push.apply(doc.errors, this.errors);\n            Array.prototype.push.apply(doc.warnings, this.warnings);\n        }\n        else {\n            doc.errors = this.errors;\n            doc.warnings = this.warnings;\n        }\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n    }\n    /**\n     * Current stream status information.\n     *\n     * Mostly useful at the end of input for an empty stream.\n     */\n    streamInfo() {\n        return {\n            comment: parsePrelude(this.prelude).comment,\n            directives: this.directives,\n            errors: this.errors,\n            warnings: this.warnings\n        };\n    }\n    /**\n     * Compose tokens into documents.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *compose(tokens, forceDoc = false, endOffset = -1) {\n        for (const token of tokens)\n            yield* this.next(token);\n        yield* this.end(forceDoc, endOffset);\n    }\n    /** Advance the composer by one CST token. */\n    *next(token) {\n        switch (token.type) {\n            case 'directive':\n                this.directives.add(token.source, (offset, message, warning) => {\n                    const pos = getErrorPos(token);\n                    pos[0] += offset;\n                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);\n                });\n                this.prelude.push(token.source);\n                this.atDirectives = true;\n                break;\n            case 'document': {\n                const doc = composeDoc(this.options, this.directives, token, this.onError);\n                if (this.atDirectives && !doc.directives.docStart)\n                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');\n                this.decorate(doc, false);\n                if (this.doc)\n                    yield this.doc;\n                this.doc = doc;\n                this.atDirectives = false;\n                break;\n            }\n            case 'byte-order-mark':\n            case 'space':\n                break;\n            case 'comment':\n            case 'newline':\n                this.prelude.push(token.source);\n                break;\n            case 'error': {\n                const msg = token.source\n                    ? `${token.message}: ${JSON.stringify(token.source)}`\n                    : token.message;\n                const error = new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\n                if (this.atDirectives || !this.doc)\n                    this.errors.push(error);\n                else\n                    this.doc.errors.push(error);\n                break;\n            }\n            case 'doc-end': {\n                if (!this.doc) {\n                    const msg = 'Unexpected doc-end without preceding document';\n                    this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));\n                    break;\n                }\n                this.doc.directives.docEnd = true;\n                const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\n                this.decorate(this.doc, true);\n                if (end.comment) {\n                    const dc = this.doc.comment;\n                    this.doc.comment = dc ? `${dc}\\n${end.comment}` : end.comment;\n                }\n                this.doc.range[2] = end.offset;\n                break;\n            }\n            default:\n                this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));\n        }\n    }\n    /**\n     * Call at end of input to yield any remaining document.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *end(forceDoc = false, endOffset = -1) {\n        if (this.doc) {\n            this.decorate(this.doc, true);\n            yield this.doc;\n            this.doc = null;\n        }\n        else if (forceDoc) {\n            const opts = Object.assign({ _directives: this.directives }, this.options);\n            const doc = new Document(undefined, opts);\n            if (this.atDirectives)\n                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\n            doc.range = [0, endOffset, endOffset];\n            this.decorate(doc, false);\n            yield doc;\n        }\n    }\n}\n\nexport { Composer };\n","/**\n * Tracks newlines during parsing in order to provide an efficient API for\n * determining the one-indexed `{ line, col }` position for any offset\n * within the input.\n */\nclass LineCounter {\n    constructor() {\n        this.lineStarts = [];\n        /**\n         * Should be called in ascending order. Otherwise, call\n         * `lineCounter.lineStarts.sort()` before calling `linePos()`.\n         */\n        this.addNewLine = (offset) => this.lineStarts.push(offset);\n        /**\n         * Performs a binary search and returns the 1-indexed { line, col }\n         * position of `offset`. If `line === 0`, `addNewLine` has never been\n         * called or `offset` is before the first known newline.\n         */\n        this.linePos = (offset) => {\n            let low = 0;\n            let high = this.lineStarts.length;\n            while (low < high) {\n                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)\n                if (this.lineStarts[mid] < offset)\n                    low = mid + 1;\n                else\n                    high = mid;\n            }\n            if (this.lineStarts[low] === offset)\n                return { line: low + 1, col: 1 };\n            if (low === 0)\n                return { line: 0, col: offset };\n            const start = this.lineStarts[low - 1];\n            return { line: low, col: offset - start + 1 };\n        };\n    }\n}\n\nexport { LineCounter };\n","import { tokenType } from './cst.js';\nimport { Lexer } from './lexer.js';\n\nfunction includesToken(list, type) {\n    for (let i = 0; i < list.length; ++i)\n        if (list[i].type === type)\n            return true;\n    return false;\n}\nfunction findNonEmptyIndex(list) {\n    for (let i = 0; i < list.length; ++i) {\n        switch (list[i].type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                break;\n            default:\n                return i;\n        }\n    }\n    return -1;\n}\nfunction isFlowToken(token) {\n    switch (token?.type) {\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'flow-collection':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getPrevProps(parent) {\n    switch (parent.type) {\n        case 'document':\n            return parent.start;\n        case 'block-map': {\n            const it = parent.items[parent.items.length - 1];\n            return it.sep ?? it.start;\n        }\n        case 'block-seq':\n            return parent.items[parent.items.length - 1].start;\n        /* istanbul ignore next should not happen */\n        default:\n            return [];\n    }\n}\n/** Note: May modify input array */\nfunction getFirstKeyStartProps(prev) {\n    if (prev.length === 0)\n        return [];\n    let i = prev.length;\n    loop: while (--i >= 0) {\n        switch (prev[i].type) {\n            case 'doc-start':\n            case 'explicit-key-ind':\n            case 'map-value-ind':\n            case 'seq-item-ind':\n            case 'newline':\n                break loop;\n        }\n    }\n    while (prev[++i]?.type === 'space') {\n        /* loop */\n    }\n    return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n    if (fc.start.type === 'flow-seq-start') {\n        for (const it of fc.items) {\n            if (it.sep &&\n                !it.value &&\n                !includesToken(it.start, 'explicit-key-ind') &&\n                !includesToken(it.sep, 'map-value-ind')) {\n                if (it.key)\n                    it.value = it.key;\n                delete it.key;\n                if (isFlowToken(it.value)) {\n                    if (it.value.end)\n                        Array.prototype.push.apply(it.value.end, it.sep);\n                    else\n                        it.value.end = it.sep;\n                }\n                else\n                    Array.prototype.push.apply(it.start, it.sep);\n                delete it.sep;\n            }\n        }\n    }\n}\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nclass Parser {\n    /**\n     * @param onNewLine - If defined, called separately with the start position of\n     *   each new line (in `parse()`, including the start of input).\n     */\n    constructor(onNewLine) {\n        /** If true, space and sequence indicators count as indentation */\n        this.atNewLine = true;\n        /** If true, next token is a scalar value */\n        this.atScalar = false;\n        /** Current indentation level */\n        this.indent = 0;\n        /** Current offset since the start of parsing */\n        this.offset = 0;\n        /** On the same line with a block map key */\n        this.onKeyLine = false;\n        /** Top indicates the node that's currently being built */\n        this.stack = [];\n        /** The source of the current token, set in parse() */\n        this.source = '';\n        /** The type of the current token, set in parse() */\n        this.type = '';\n        // Must be defined after `next()`\n        this.lexer = new Lexer();\n        this.onNewLine = onNewLine;\n    }\n    /**\n     * Parse `source` as a YAML stream.\n     * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n     *\n     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n     *\n     * @returns A generator of tokens representing each directive, document, and other structure.\n     */\n    *parse(source, incomplete = false) {\n        if (this.onNewLine && this.offset === 0)\n            this.onNewLine(0);\n        for (const lexeme of this.lexer.lex(source, incomplete))\n            yield* this.next(lexeme);\n        if (!incomplete)\n            yield* this.end();\n    }\n    /**\n     * Advance the parser by the `source` of one lexical token.\n     */\n    *next(source) {\n        this.source = source;\n        if (this.atScalar) {\n            this.atScalar = false;\n            yield* this.step();\n            this.offset += source.length;\n            return;\n        }\n        const type = tokenType(source);\n        if (!type) {\n            const message = `Not a YAML token: ${source}`;\n            yield* this.pop({ type: 'error', offset: this.offset, message, source });\n            this.offset += source.length;\n        }\n        else if (type === 'scalar') {\n            this.atNewLine = false;\n            this.atScalar = true;\n            this.type = 'scalar';\n        }\n        else {\n            this.type = type;\n            yield* this.step();\n            switch (type) {\n                case 'newline':\n                    this.atNewLine = true;\n                    this.indent = 0;\n                    if (this.onNewLine)\n                        this.onNewLine(this.offset + source.length);\n                    break;\n                case 'space':\n                    if (this.atNewLine && source[0] === ' ')\n                        this.indent += source.length;\n                    break;\n                case 'explicit-key-ind':\n                case 'map-value-ind':\n                case 'seq-item-ind':\n                    if (this.atNewLine)\n                        this.indent += source.length;\n                    break;\n                case 'doc-mode':\n                case 'flow-error-end':\n                    return;\n                default:\n                    this.atNewLine = false;\n            }\n            this.offset += source.length;\n        }\n    }\n    /** Call at end of input to push out any remaining constructions */\n    *end() {\n        while (this.stack.length > 0)\n            yield* this.pop();\n    }\n    get sourceToken() {\n        const st = {\n            type: this.type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n        return st;\n    }\n    *step() {\n        const top = this.peek(1);\n        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {\n            while (this.stack.length > 0)\n                yield* this.pop();\n            this.stack.push({\n                type: 'doc-end',\n                offset: this.offset,\n                source: this.source\n            });\n            return;\n        }\n        if (!top)\n            return yield* this.stream();\n        switch (top.type) {\n            case 'document':\n                return yield* this.document(top);\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return yield* this.scalar(top);\n            case 'block-scalar':\n                return yield* this.blockScalar(top);\n            case 'block-map':\n                return yield* this.blockMap(top);\n            case 'block-seq':\n                return yield* this.blockSequence(top);\n            case 'flow-collection':\n                return yield* this.flowCollection(top);\n            case 'doc-end':\n                return yield* this.documentEnd(top);\n        }\n        /* istanbul ignore next should not happen */\n        yield* this.pop();\n    }\n    peek(n) {\n        return this.stack[this.stack.length - n];\n    }\n    *pop(error) {\n        const token = error ?? this.stack.pop();\n        /* istanbul ignore if should not happen */\n        if (!token) {\n            const message = 'Tried to pop an empty stack';\n            yield { type: 'error', offset: this.offset, source: '', message };\n        }\n        else if (this.stack.length === 0) {\n            yield token;\n        }\n        else {\n            const top = this.peek(1);\n            if (token.type === 'block-scalar') {\n                // Block scalars use their parent rather than header indent\n                token.indent = 'indent' in top ? top.indent : 0;\n            }\n            else if (token.type === 'flow-collection' && top.type === 'document') {\n                // Ignore all indent for top-level flow collections\n                token.indent = 0;\n            }\n            if (token.type === 'flow-collection')\n                fixFlowSeqItems(token);\n            switch (top.type) {\n                case 'document':\n                    top.value = token;\n                    break;\n                case 'block-scalar':\n                    top.props.push(token); // error\n                    break;\n                case 'block-map': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value) {\n                        top.items.push({ start: [], key: token, sep: [] });\n                        this.onKeyLine = true;\n                        return;\n                    }\n                    else if (it.sep) {\n                        it.value = token;\n                    }\n                    else {\n                        Object.assign(it, { key: token, sep: [] });\n                        this.onKeyLine = !it.explicitKey;\n                        return;\n                    }\n                    break;\n                }\n                case 'block-seq': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value)\n                        top.items.push({ start: [], value: token });\n                    else\n                        it.value = token;\n                    break;\n                }\n                case 'flow-collection': {\n                    const it = top.items[top.items.length - 1];\n                    if (!it || it.value)\n                        top.items.push({ start: [], key: token, sep: [] });\n                    else if (it.sep)\n                        it.value = token;\n                    else\n                        Object.assign(it, { key: token, sep: [] });\n                    return;\n                }\n                /* istanbul ignore next should not happen */\n                default:\n                    yield* this.pop();\n                    yield* this.pop(token);\n            }\n            if ((top.type === 'document' ||\n                top.type === 'block-map' ||\n                top.type === 'block-seq') &&\n                (token.type === 'block-map' || token.type === 'block-seq')) {\n                const last = token.items[token.items.length - 1];\n                if (last &&\n                    !last.sep &&\n                    !last.value &&\n                    last.start.length > 0 &&\n                    findNonEmptyIndex(last.start) === -1 &&\n                    (token.indent === 0 ||\n                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\n                    if (top.type === 'document')\n                        top.end = last.start;\n                    else\n                        top.items.push({ start: last.start });\n                    token.items.splice(-1, 1);\n                }\n            }\n        }\n    }\n    *stream() {\n        switch (this.type) {\n            case 'directive-line':\n                yield { type: 'directive', offset: this.offset, source: this.source };\n                return;\n            case 'byte-order-mark':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                yield this.sourceToken;\n                return;\n            case 'doc-mode':\n            case 'doc-start': {\n                const doc = {\n                    type: 'document',\n                    offset: this.offset,\n                    start: []\n                };\n                if (this.type === 'doc-start')\n                    doc.start.push(this.sourceToken);\n                this.stack.push(doc);\n                return;\n            }\n        }\n        yield {\n            type: 'error',\n            offset: this.offset,\n            message: `Unexpected ${this.type} token in YAML stream`,\n            source: this.source\n        };\n    }\n    *document(doc) {\n        if (doc.value)\n            return yield* this.lineEnd(doc);\n        switch (this.type) {\n            case 'doc-start': {\n                if (findNonEmptyIndex(doc.start) !== -1) {\n                    yield* this.pop();\n                    yield* this.step();\n                }\n                else\n                    doc.start.push(this.sourceToken);\n                return;\n            }\n            case 'anchor':\n            case 'tag':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                doc.start.push(this.sourceToken);\n                return;\n        }\n        const bv = this.startBlockValue(doc);\n        if (bv)\n            this.stack.push(bv);\n        else {\n            yield {\n                type: 'error',\n                offset: this.offset,\n                message: `Unexpected ${this.type} token in YAML document`,\n                source: this.source\n            };\n        }\n    }\n    *scalar(scalar) {\n        if (this.type === 'map-value-ind') {\n            const prev = getPrevProps(this.peek(2));\n            const start = getFirstKeyStartProps(prev);\n            let sep;\n            if (scalar.end) {\n                sep = scalar.end;\n                sep.push(this.sourceToken);\n                delete scalar.end;\n            }\n            else\n                sep = [this.sourceToken];\n            const map = {\n                type: 'block-map',\n                offset: scalar.offset,\n                indent: scalar.indent,\n                items: [{ start, key: scalar, sep }]\n            };\n            this.onKeyLine = true;\n            this.stack[this.stack.length - 1] = map;\n        }\n        else\n            yield* this.lineEnd(scalar);\n    }\n    *blockScalar(scalar) {\n        switch (this.type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                scalar.props.push(this.sourceToken);\n                return;\n            case 'scalar':\n                scalar.source = this.source;\n                // block-scalar source includes trailing newline\n                this.atNewLine = true;\n                this.indent = 0;\n                if (this.onNewLine) {\n                    let nl = this.source.indexOf('\\n') + 1;\n                    while (nl !== 0) {\n                        this.onNewLine(this.offset + nl);\n                        nl = this.source.indexOf('\\n', nl) + 1;\n                    }\n                }\n                yield* this.pop();\n                break;\n            /* istanbul ignore next should not happen */\n            default:\n                yield* this.pop();\n                yield* this.step();\n        }\n    }\n    *blockMap(map) {\n        const it = map.items[map.items.length - 1];\n        // it.sep is true-ish if pair already has key or : separator\n        switch (this.type) {\n            case 'newline':\n                this.onKeyLine = false;\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value) {\n                    map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    if (this.atIndentedComment(it.start, map.indent)) {\n                        const prev = map.items[map.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            map.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n        }\n        if (this.indent >= map.indent) {\n            const atMapIndent = !this.onKeyLine && this.indent === map.indent;\n            const atNextItem = atMapIndent &&\n                (it.sep || it.explicitKey) &&\n                this.type !== 'seq-item-ind';\n            // For empty nodes, assign newline-separated not indented empty tokens to following node\n            let start = [];\n            if (atNextItem && it.sep && !it.value) {\n                const nl = [];\n                for (let i = 0; i < it.sep.length; ++i) {\n                    const st = it.sep[i];\n                    switch (st.type) {\n                        case 'newline':\n                            nl.push(i);\n                            break;\n                        case 'space':\n                            break;\n                        case 'comment':\n                            if (st.indent > map.indent)\n                                nl.length = 0;\n                            break;\n                        default:\n                            nl.length = 0;\n                    }\n                }\n                if (nl.length >= 2)\n                    start = it.sep.splice(nl[1]);\n            }\n            switch (this.type) {\n                case 'anchor':\n                case 'tag':\n                    if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        it.sep.push(this.sourceToken);\n                    }\n                    else {\n                        it.start.push(this.sourceToken);\n                    }\n                    return;\n                case 'explicit-key-ind':\n                    if (!it.sep && !it.explicitKey) {\n                        it.start.push(this.sourceToken);\n                        it.explicitKey = true;\n                    }\n                    else if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start, explicitKey: true });\n                    }\n                    else {\n                        this.stack.push({\n                            type: 'block-map',\n                            offset: this.offset,\n                            indent: this.indent,\n                            items: [{ start: [this.sourceToken], explicitKey: true }]\n                        });\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'map-value-ind':\n                    if (it.explicitKey) {\n                        if (!it.sep) {\n                            if (includesToken(it.start, 'newline')) {\n                                Object.assign(it, { key: null, sep: [this.sourceToken] });\n                            }\n                            else {\n                                const start = getFirstKeyStartProps(it.start);\n                                this.stack.push({\n                                    type: 'block-map',\n                                    offset: this.offset,\n                                    indent: this.indent,\n                                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                                });\n                            }\n                        }\n                        else if (it.value) {\n                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else if (isFlowToken(it.key) &&\n                            !includesToken(it.sep, 'newline')) {\n                            const start = getFirstKeyStartProps(it.start);\n                            const key = it.key;\n                            const sep = it.sep;\n                            sep.push(this.sourceToken);\n                            // @ts-expect-error type guard is wrong here\n                            delete it.key;\n                            // @ts-expect-error type guard is wrong here\n                            delete it.sep;\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key, sep }]\n                            });\n                        }\n                        else if (start.length > 0) {\n                            // Not actually at next item\n                            it.sep = it.sep.concat(start, this.sourceToken);\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    else {\n                        if (!it.sep) {\n                            Object.assign(it, { key: null, sep: [this.sourceToken] });\n                        }\n                        else if (it.value || atNextItem) {\n                            map.items.push({ start, key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start: [], key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (atNextItem || it.value) {\n                        map.items.push({ start, key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        this.stack.push(fs);\n                    }\n                    else {\n                        Object.assign(it, { key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    return;\n                }\n                default: {\n                    const bv = this.startBlockValue(map);\n                    if (bv) {\n                        if (bv.type === 'block-seq') {\n                            if (!it.explicitKey &&\n                                it.sep &&\n                                !includesToken(it.sep, 'newline')) {\n                                yield* this.pop({\n                                    type: 'error',\n                                    offset: this.offset,\n                                    message: 'Unexpected block-seq-ind on same line with key',\n                                    source: this.source\n                                });\n                                return;\n                            }\n                        }\n                        else if (atMapIndent) {\n                            map.items.push({ start });\n                        }\n                        this.stack.push(bv);\n                        return;\n                    }\n                }\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *blockSequence(seq) {\n        const it = seq.items[seq.items.length - 1];\n        switch (this.type) {\n            case 'newline':\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        seq.items.push({ start: [this.sourceToken] });\n                }\n                else\n                    it.start.push(this.sourceToken);\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value)\n                    seq.items.push({ start: [this.sourceToken] });\n                else {\n                    if (this.atIndentedComment(it.start, seq.indent)) {\n                        const prev = seq.items[seq.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            seq.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'anchor':\n            case 'tag':\n                if (it.value || this.indent <= seq.indent)\n                    break;\n                it.start.push(this.sourceToken);\n                return;\n            case 'seq-item-ind':\n                if (this.indent !== seq.indent)\n                    break;\n                if (it.value || includesToken(it.start, 'seq-item-ind'))\n                    seq.items.push({ start: [this.sourceToken] });\n                else\n                    it.start.push(this.sourceToken);\n                return;\n        }\n        if (this.indent > seq.indent) {\n            const bv = this.startBlockValue(seq);\n            if (bv) {\n                this.stack.push(bv);\n                return;\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *flowCollection(fc) {\n        const it = fc.items[fc.items.length - 1];\n        if (this.type === 'flow-error-end') {\n            let top;\n            do {\n                yield* this.pop();\n                top = this.peek(1);\n            } while (top && top.type === 'flow-collection');\n        }\n        else if (fc.end.length === 0) {\n            switch (this.type) {\n                case 'comma':\n                case 'explicit-key-ind':\n                    if (!it || it.sep)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'map-value-ind':\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        Object.assign(it, { key: null, sep: [this.sourceToken] });\n                    return;\n                case 'space':\n                case 'comment':\n                case 'newline':\n                case 'anchor':\n                case 'tag':\n                    if (!it || it.value)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: fs, sep: [] });\n                    else if (it.sep)\n                        this.stack.push(fs);\n                    else\n                        Object.assign(it, { key: fs, sep: [] });\n                    return;\n                }\n                case 'flow-map-end':\n                case 'flow-seq-end':\n                    fc.end.push(this.sourceToken);\n                    return;\n            }\n            const bv = this.startBlockValue(fc);\n            /* istanbul ignore else should not happen */\n            if (bv)\n                this.stack.push(bv);\n            else {\n                yield* this.pop();\n                yield* this.step();\n            }\n        }\n        else {\n            const parent = this.peek(2);\n            if (parent.type === 'block-map' &&\n                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||\n                    (this.type === 'newline' &&\n                        !parent.items[parent.items.length - 1].sep))) {\n                yield* this.pop();\n                yield* this.step();\n            }\n            else if (this.type === 'map-value-ind' &&\n                parent.type !== 'flow-collection') {\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                fixFlowSeqItems(fc);\n                const sep = fc.end.splice(1, fc.end.length);\n                sep.push(this.sourceToken);\n                const map = {\n                    type: 'block-map',\n                    offset: fc.offset,\n                    indent: fc.indent,\n                    items: [{ start, key: fc, sep }]\n                };\n                this.onKeyLine = true;\n                this.stack[this.stack.length - 1] = map;\n            }\n            else {\n                yield* this.lineEnd(fc);\n            }\n        }\n    }\n    flowScalar(type) {\n        if (this.onNewLine) {\n            let nl = this.source.indexOf('\\n') + 1;\n            while (nl !== 0) {\n                this.onNewLine(this.offset + nl);\n                nl = this.source.indexOf('\\n', nl) + 1;\n            }\n        }\n        return {\n            type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n    }\n    startBlockValue(parent) {\n        switch (this.type) {\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return this.flowScalar(this.type);\n            case 'block-scalar-header':\n                return {\n                    type: 'block-scalar',\n                    offset: this.offset,\n                    indent: this.indent,\n                    props: [this.sourceToken],\n                    source: ''\n                };\n            case 'flow-map-start':\n            case 'flow-seq-start':\n                return {\n                    type: 'flow-collection',\n                    offset: this.offset,\n                    indent: this.indent,\n                    start: this.sourceToken,\n                    items: [],\n                    end: []\n                };\n            case 'seq-item-ind':\n                return {\n                    type: 'block-seq',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start: [this.sourceToken] }]\n                };\n            case 'explicit-key-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                start.push(this.sourceToken);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, explicitKey: true }]\n                };\n            }\n            case 'map-value-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                };\n            }\n        }\n        return null;\n    }\n    atIndentedComment(start, indent) {\n        if (this.type !== 'comment')\n            return false;\n        if (this.indent <= indent)\n            return false;\n        return start.every(st => st.type === 'newline' || st.type === 'space');\n    }\n    *documentEnd(docEnd) {\n        if (this.type !== 'doc-mode') {\n            if (docEnd.end)\n                docEnd.end.push(this.sourceToken);\n            else\n                docEnd.end = [this.sourceToken];\n            if (this.type === 'newline')\n                yield* this.pop();\n        }\n    }\n    *lineEnd(token) {\n        switch (this.type) {\n            case 'comma':\n            case 'doc-start':\n            case 'doc-end':\n            case 'flow-seq-end':\n            case 'flow-map-end':\n            case 'map-value-ind':\n                yield* this.pop();\n                yield* this.step();\n                break;\n            case 'newline':\n                this.onKeyLine = false;\n            // fallthrough\n            case 'space':\n            case 'comment':\n            default:\n                // all other values are errors\n                if (token.end)\n                    token.end.push(this.sourceToken);\n                else\n                    token.end = [this.sourceToken];\n                if (this.type === 'newline')\n                    yield* this.pop();\n        }\n    }\n}\n\nexport { Parser };\n","import { Composer } from './compose/composer.js';\nimport { Document } from './doc/Document.js';\nimport { prettifyError, YAMLParseError } from './errors.js';\nimport { warn } from './log.js';\nimport { isDocument } from './nodes/identity.js';\nimport { LineCounter } from './parse/line-counter.js';\nimport { Parser } from './parse/parser.js';\n\nfunction parseOptions(options) {\n    const prettyErrors = options.prettyErrors !== false;\n    const lineCounter = options.lineCounter || (prettyErrors && new LineCounter()) || null;\n    return { lineCounter, prettyErrors };\n}\n/**\n * Parse the input as a stream of YAML documents.\n *\n * Documents should be separated from each other by `...` or `---` marker lines.\n *\n * @returns If an empty `docs` array is returned, it will be of type\n *   EmptyStream and contain additional stream information. In\n *   TypeScript, you should use `'empty' in docs` as a type guard for it.\n */\nfunction parseAllDocuments(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser = new Parser(lineCounter?.addNewLine);\n    const composer = new Composer(options);\n    const docs = Array.from(composer.compose(parser.parse(source)));\n    if (prettyErrors && lineCounter)\n        for (const doc of docs) {\n            doc.errors.forEach(prettifyError(source, lineCounter));\n            doc.warnings.forEach(prettifyError(source, lineCounter));\n        }\n    if (docs.length > 0)\n        return docs;\n    return Object.assign([], { empty: true }, composer.streamInfo());\n}\n/** Parse an input string into a single YAML.Document */\nfunction parseDocument(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser = new Parser(lineCounter?.addNewLine);\n    const composer = new Composer(options);\n    // `doc` is always set by compose.end(true) at the very latest\n    let doc = null;\n    for (const _doc of composer.compose(parser.parse(source), true, source.length)) {\n        if (!doc)\n            doc = _doc;\n        else if (doc.options.logLevel !== 'silent') {\n            doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\n            break;\n        }\n    }\n    if (prettyErrors && lineCounter) {\n        doc.errors.forEach(prettifyError(source, lineCounter));\n        doc.warnings.forEach(prettifyError(source, lineCounter));\n    }\n    return doc;\n}\nfunction parse(src, reviver, options) {\n    let _reviver = undefined;\n    if (typeof reviver === 'function') {\n        _reviver = reviver;\n    }\n    else if (options === undefined && reviver && typeof reviver === 'object') {\n        options = reviver;\n    }\n    const doc = parseDocument(src, options);\n    if (!doc)\n        return null;\n    doc.warnings.forEach(warning => warn(doc.options.logLevel, warning));\n    if (doc.errors.length > 0) {\n        if (doc.options.logLevel !== 'silent')\n            throw doc.errors[0];\n        else\n            doc.errors = [];\n    }\n    return doc.toJS(Object.assign({ reviver: _reviver }, options));\n}\nfunction stringify(value, replacer, options) {\n    let _replacer = null;\n    if (typeof replacer === 'function' || Array.isArray(replacer)) {\n        _replacer = replacer;\n    }\n    else if (options === undefined && replacer) {\n        options = replacer;\n    }\n    if (typeof options === 'string')\n        options = options.length;\n    if (typeof options === 'number') {\n        const indent = Math.round(options);\n        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };\n    }\n    if (value === undefined) {\n        const { keepUndefined } = options ?? replacer ?? {};\n        if (!keepUndefined)\n            return undefined;\n    }\n    if (isDocument(value) && !_replacer)\n        return value.toString(options);\n    return new Document(value, _replacer, options).toString(options);\n}\n\nexport { parse, parseAllDocuments, parseDocument, stringify };\n","import { WEBUI_API_BASE_URL, WEBUI_BASE_URL } from '$lib/constants';\nimport { convertOpenApiToToolPayload } from '$lib/utils';\nimport { getOpenAIModelsDirect } from './openai';\n\nimport { parse } from 'yaml';\nimport { toast } from 'svelte-sonner';\n\nexport const getModels = async (\n\ttoken: string = '',\n\tconnections: object | null = null,\n\tbase: boolean = false\n) => {\n\tlet error = null;\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/models${base ? '/base' : ''}`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\terror = err;\n\t\t\tconsole.error(err);\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\tlet models = res?.data ?? [];\n\n\tif (connections && !base) {\n\t\tlet localModels = [];\n\n\t\tif (connections) {\n\t\t\tconst OPENAI_API_BASE_URLS = connections.OPENAI_API_BASE_URLS;\n\t\t\tconst OPENAI_API_KEYS = connections.OPENAI_API_KEYS;\n\t\t\tconst OPENAI_API_CONFIGS = connections.OPENAI_API_CONFIGS;\n\n\t\t\tconst requests = [];\n\t\t\tfor (const idx in OPENAI_API_BASE_URLS) {\n\t\t\t\tconst url = OPENAI_API_BASE_URLS[idx];\n\n\t\t\t\tif (idx.toString() in OPENAI_API_CONFIGS) {\n\t\t\t\t\tconst apiConfig = OPENAI_API_CONFIGS[idx.toString()] ?? {};\n\n\t\t\t\t\tconst enable = apiConfig?.enable ?? true;\n\t\t\t\t\tconst modelIds = apiConfig?.model_ids ?? [];\n\n\t\t\t\t\tif (enable) {\n\t\t\t\t\t\tif (modelIds.length > 0) {\n\t\t\t\t\t\t\tconst modelList = {\n\t\t\t\t\t\t\t\tobject: 'list',\n\t\t\t\t\t\t\t\tdata: modelIds.map((modelId) => ({\n\t\t\t\t\t\t\t\t\tid: modelId,\n\t\t\t\t\t\t\t\t\tname: modelId,\n\t\t\t\t\t\t\t\t\towned_by: 'openai',\n\t\t\t\t\t\t\t\t\topenai: { id: modelId },\n\t\t\t\t\t\t\t\t\turlIdx: idx\n\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\trequests.push(\n\t\t\t\t\t\t\t\t(async () => {\n\t\t\t\t\t\t\t\t\treturn modelList;\n\t\t\t\t\t\t\t\t})()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trequests.push(\n\t\t\t\t\t\t\t\t(async () => {\n\t\t\t\t\t\t\t\t\treturn await getOpenAIModelsDirect(url, OPENAI_API_KEYS[idx])\n\t\t\t\t\t\t\t\t\t\t.then((res) => {\n\t\t\t\t\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t.catch((err) => {\n\t\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\t\tobject: 'list',\n\t\t\t\t\t\t\t\t\t\t\t\tdata: [],\n\t\t\t\t\t\t\t\t\t\t\t\turlIdx: idx\n\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t})()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trequests.push(\n\t\t\t\t\t\t\t(async () => {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tobject: 'list',\n\t\t\t\t\t\t\t\t\tdata: [],\n\t\t\t\t\t\t\t\t\turlIdx: idx\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t})()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst responses = await Promise.all(requests);\n\n\t\t\tfor (const idx in responses) {\n\t\t\t\tconst response = responses[idx];\n\t\t\t\tconst apiConfig = OPENAI_API_CONFIGS[idx.toString()] ?? {};\n\n\t\t\t\tlet models = Array.isArray(response) ? response : (response?.data ?? []);\n\t\t\t\tmodels = models.map((model) => ({ ...model, openai: { id: model.id }, urlIdx: idx }));\n\n\t\t\t\tconst prefixId = apiConfig.prefix_id;\n\t\t\t\tif (prefixId) {\n\t\t\t\t\tfor (const model of models) {\n\t\t\t\t\t\tmodel.id = `${prefixId}.${model.id}`;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst tags = apiConfig.tags;\n\t\t\t\tif (tags) {\n\t\t\t\t\tfor (const model of models) {\n\t\t\t\t\t\tmodel.tags = tags;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlocalModels = localModels.concat(models);\n\t\t\t}\n\t\t}\n\n\t\tmodels = models.concat(\n\t\t\tlocalModels.map((model) => ({\n\t\t\t\t...model,\n\t\t\t\tname: model?.name ?? model?.id,\n\t\t\t\tdirect: true\n\t\t\t}))\n\t\t);\n\n\t\t// Remove duplicates\n\t\tconst modelsMap = {};\n\t\tfor (const model of models) {\n\t\t\tmodelsMap[model.id] = model;\n\t\t}\n\n\t\tmodels = Object.values(modelsMap);\n\t}\n\n\treturn models;\n};\n\ntype ChatCompletedForm = {\n\tmodel: string;\n\tmessages: string[];\n\tchat_id: string;\n\tsession_id: string;\n};\n\nexport const chatCompleted = async (token: string, body: ChatCompletedForm) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/chat/completed`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t},\n\t\tbody: JSON.stringify(body)\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\ntype ChatActionForm = {\n\tmodel: string;\n\tmessages: string[];\n\tchat_id: string;\n};\n\nexport const chatAction = async (token: string, action_id: string, body: ChatActionForm) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/chat/actions/${action_id}`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t},\n\t\tbody: JSON.stringify(body)\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const stopTask = async (token: string, id: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/tasks/stop/${id}`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getTaskIdsByChatId = async (token: string, chat_id: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/tasks/chat/${chat_id}`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getToolServerData = async (token: string, url: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${url}`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\t// Check if URL ends with .yaml or .yml to determine format\n\t\t\tif (url.toLowerCase().endsWith('.yaml') || url.toLowerCase().endsWith('.yml')) {\n\t\t\t\tif (!res.ok) throw await res.text();\n\t\t\t\tconst text = await res.text();\n\t\t\t\treturn parse(text);\n\t\t\t} else {\n\t\t\t\tif (!res.ok) throw await res.json();\n\t\t\t\treturn res.json();\n\t\t\t}\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\tconst data = {\n\t\topenapi: res,\n\t\tinfo: res.info,\n\t\tspecs: convertOpenApiToToolPayload(res)\n\t};\n\n\tconsole.log(data);\n\treturn data;\n};\n\nexport const getToolServersData = async (i18n, servers: object[]) => {\n\treturn (\n\t\tawait Promise.all(\n\t\t\tservers\n\t\t\t\t.filter((server) => server?.config?.enable)\n\t\t\t\t.map(async (server) => {\n\t\t\t\t\tconst data = await getToolServerData(\n\t\t\t\t\t\t(server?.auth_type ?? 'bearer') === 'bearer' ? server?.key : localStorage.token,\n\t\t\t\t\t\t(server?.path ?? '').includes('://')\n\t\t\t\t\t\t\t? server?.path\n\t\t\t\t\t\t\t: `${server?.url}${(server?.path ?? '').startsWith('/') ? '' : '/'}${server?.path}`\n\t\t\t\t\t).catch((err) => {\n\t\t\t\t\t\ttoast.error(\n\t\t\t\t\t\t\ti18n.t(`Failed to connect to {{URL}} OpenAPI tool server`, {\n\t\t\t\t\t\t\t\tURL: (server?.path ?? '').includes('://')\n\t\t\t\t\t\t\t\t\t? server?.path\n\t\t\t\t\t\t\t\t\t: `${server?.url}${(server?.path ?? '').startsWith('/') ? '' : '/'}${server?.path}`\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t});\n\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\tconst { openapi, info, specs } = data;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\turl: server?.url,\n\t\t\t\t\t\t\topenapi: openapi,\n\t\t\t\t\t\t\tinfo: info,\n\t\t\t\t\t\t\tspecs: specs\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t)\n\t).filter((server) => server);\n};\n\nexport const executeToolServer = async (\n\ttoken: string,\n\turl: string,\n\tname: string,\n\tparams: Record<string, any>,\n\tserverData: { openapi: any; info: any; specs: any }\n) => {\n\tlet error = null;\n\n\ttry {\n\t\t// Find the matching operationId in the OpenAPI spec\n\t\tconst matchingRoute = Object.entries(serverData.openapi.paths).find(([_, methods]) =>\n\t\t\tObject.entries(methods as any).some(([__, operation]: any) => operation.operationId === name)\n\t\t);\n\n\t\tif (!matchingRoute) {\n\t\t\tthrow new Error(`No matching route found for operationId: ${name}`);\n\t\t}\n\n\t\tconst [routePath, methods] = matchingRoute;\n\n\t\tconst methodEntry = Object.entries(methods as any).find(\n\t\t\t([_, operation]: any) => operation.operationId === name\n\t\t);\n\n\t\tif (!methodEntry) {\n\t\t\tthrow new Error(`No matching method found for operationId: ${name}`);\n\t\t}\n\n\t\tconst [httpMethod, operation]: [string, any] = methodEntry;\n\n\t\t// Split parameters by type\n\t\tconst pathParams: Record<string, any> = {};\n\t\tconst queryParams: Record<string, any> = {};\n\t\tlet bodyParams: any = {};\n\n\t\tif (operation.parameters) {\n\t\t\toperation.parameters.forEach((param: any) => {\n\t\t\t\tconst paramName = param.name;\n\t\t\t\tconst paramIn = param.in;\n\t\t\t\tif (params.hasOwnProperty(paramName)) {\n\t\t\t\t\tif (paramIn === 'path') {\n\t\t\t\t\t\tpathParams[paramName] = params[paramName];\n\t\t\t\t\t} else if (paramIn === 'query') {\n\t\t\t\t\t\tqueryParams[paramName] = params[paramName];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet finalUrl = `${url}${routePath}`;\n\n\t\t// Replace path parameters (`{param}`)\n\t\tObject.entries(pathParams).forEach(([key, value]) => {\n\t\t\tfinalUrl = finalUrl.replace(new RegExp(`{${key}}`, 'g'), encodeURIComponent(value));\n\t\t});\n\n\t\t// Append query parameters to URL if any\n\t\tif (Object.keys(queryParams).length > 0) {\n\t\t\tconst queryString = new URLSearchParams(\n\t\t\t\tObject.entries(queryParams).map(([k, v]) => [k, String(v)])\n\t\t\t).toString();\n\t\t\tfinalUrl += `?${queryString}`;\n\t\t}\n\n\t\t// Handle requestBody composite\n\t\tif (operation.requestBody && operation.requestBody.content) {\n\t\t\tconst contentType = Object.keys(operation.requestBody.content)[0];\n\t\t\tif (params !== undefined) {\n\t\t\t\tbodyParams = params;\n\t\t\t} else {\n\t\t\t\t// Optional: Fallback or explicit error if body is expected but not provided\n\t\t\t\tthrow new Error(`Request body expected for operation '${name}' but none found.`);\n\t\t\t}\n\t\t}\n\n\t\t// Prepare headers and request options\n\t\tconst headers: Record<string, string> = {\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t};\n\n\t\tlet requestOptions: RequestInit = {\n\t\t\tmethod: httpMethod.toUpperCase(),\n\t\t\theaders\n\t\t};\n\n\t\tif (['post', 'put', 'patch'].includes(httpMethod.toLowerCase()) && operation.requestBody) {\n\t\t\trequestOptions.body = JSON.stringify(bodyParams);\n\t\t}\n\n\t\tconst res = await fetch(finalUrl, requestOptions);\n\t\tif (!res.ok) {\n\t\t\tconst resText = await res.text();\n\t\t\tthrow new Error(`HTTP error! Status: ${res.status}. Message: ${resText}`);\n\t\t}\n\n\t\treturn await res.json();\n\t} catch (err: any) {\n\t\terror = err.message;\n\t\tconsole.error('API Request Error:', error);\n\t\treturn { error };\n\t}\n};\n\nexport const getTaskConfig = async (token: string = '') => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/tasks/config`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const updateTaskConfig = async (token: string, config: object) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/tasks/config/update`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t},\n\t\tbody: JSON.stringify(config)\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const generateTitle = async (\n\ttoken: string = '',\n\tmodel: string,\n\tmessages: object[],\n\tchat_id?: string\n) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/tasks/title/completions`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tmodel: model,\n\t\t\tmessages: messages,\n\t\t\t...(chat_id && { chat_id: chat_id })\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\ttry {\n\t\t// Step 1: Safely extract the response string\n\t\tconst response = res?.choices[0]?.message?.content ?? '';\n\n\t\t// Step 2: Attempt to fix common JSON format issues like single quotes\n\t\tconst sanitizedResponse = response.replace(/['‘’`]/g, '\"'); // Convert single quotes to double quotes for valid JSON\n\n\t\t// Step 3: Find the relevant JSON block within the response\n\t\tconst jsonStartIndex = sanitizedResponse.indexOf('{');\n\t\tconst jsonEndIndex = sanitizedResponse.lastIndexOf('}');\n\n\t\t// Step 4: Check if we found a valid JSON block (with both `{` and `}`)\n\t\tif (jsonStartIndex !== -1 && jsonEndIndex !== -1) {\n\t\t\tconst jsonResponse = sanitizedResponse.substring(jsonStartIndex, jsonEndIndex + 1);\n\n\t\t\t// Step 5: Parse the JSON block\n\t\t\tconst parsed = JSON.parse(jsonResponse);\n\n\t\t\t// Step 6: If there's a \"tags\" key, return the tags array; otherwise, return an empty array\n\t\t\tif (parsed && parsed.title) {\n\t\t\t\treturn parsed.title;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// If no valid JSON block found, return an empty array\n\t\treturn null;\n\t} catch (e) {\n\t\t// Catch and safely return empty array on any parsing errors\n\t\tconsole.error('Failed to parse response: ', e);\n\t\treturn null;\n\t}\n};\n\nexport const generateFollowUps = async (\n\ttoken: string = '',\n\tmodel: string,\n\tmessages: string,\n\tchat_id?: string\n) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/tasks/follow_ups/completions`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tmodel: model,\n\t\t\tmessages: messages,\n\t\t\t...(chat_id && { chat_id: chat_id })\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\ttry {\n\t\t// Step 1: Safely extract the response string\n\t\tconst response = res?.choices[0]?.message?.content ?? '';\n\n\t\t// Step 2: Attempt to fix common JSON format issues like single quotes\n\t\tconst sanitizedResponse = response.replace(/['‘’`]/g, '\"'); // Convert single quotes to double quotes for valid JSON\n\n\t\t// Step 3: Find the relevant JSON block within the response\n\t\tconst jsonStartIndex = sanitizedResponse.indexOf('{');\n\t\tconst jsonEndIndex = sanitizedResponse.lastIndexOf('}');\n\n\t\t// Step 4: Check if we found a valid JSON block (with both `{` and `}`)\n\t\tif (jsonStartIndex !== -1 && jsonEndIndex !== -1) {\n\t\t\tconst jsonResponse = sanitizedResponse.substring(jsonStartIndex, jsonEndIndex + 1);\n\n\t\t\t// Step 5: Parse the JSON block\n\t\t\tconst parsed = JSON.parse(jsonResponse);\n\n\t\t\t// Step 6: If there's a \"follow_ups\" key, return the follow_ups array; otherwise, return an empty array\n\t\t\tif (parsed && parsed.follow_ups) {\n\t\t\t\treturn Array.isArray(parsed.follow_ups) ? parsed.follow_ups : [];\n\t\t\t} else {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\n\t\t// If no valid JSON block found, return an empty array\n\t\treturn [];\n\t} catch (e) {\n\t\t// Catch and safely return empty array on any parsing errors\n\t\tconsole.error('Failed to parse response: ', e);\n\t\treturn [];\n\t}\n};\n\nexport const generateTags = async (\n\ttoken: string = '',\n\tmodel: string,\n\tmessages: string,\n\tchat_id?: string\n) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/tasks/tags/completions`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tmodel: model,\n\t\t\tmessages: messages,\n\t\t\t...(chat_id && { chat_id: chat_id })\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\ttry {\n\t\t// Step 1: Safely extract the response string\n\t\tconst response = res?.choices[0]?.message?.content ?? '';\n\n\t\t// Step 2: Attempt to fix common JSON format issues like single quotes\n\t\tconst sanitizedResponse = response.replace(/['‘’`]/g, '\"'); // Convert single quotes to double quotes for valid JSON\n\n\t\t// Step 3: Find the relevant JSON block within the response\n\t\tconst jsonStartIndex = sanitizedResponse.indexOf('{');\n\t\tconst jsonEndIndex = sanitizedResponse.lastIndexOf('}');\n\n\t\t// Step 4: Check if we found a valid JSON block (with both `{` and `}`)\n\t\tif (jsonStartIndex !== -1 && jsonEndIndex !== -1) {\n\t\t\tconst jsonResponse = sanitizedResponse.substring(jsonStartIndex, jsonEndIndex + 1);\n\n\t\t\t// Step 5: Parse the JSON block\n\t\t\tconst parsed = JSON.parse(jsonResponse);\n\n\t\t\t// Step 6: If there's a \"tags\" key, return the tags array; otherwise, return an empty array\n\t\t\tif (parsed && parsed.tags) {\n\t\t\t\treturn Array.isArray(parsed.tags) ? parsed.tags : [];\n\t\t\t} else {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\n\t\t// If no valid JSON block found, return an empty array\n\t\treturn [];\n\t} catch (e) {\n\t\t// Catch and safely return empty array on any parsing errors\n\t\tconsole.error('Failed to parse response: ', e);\n\t\treturn [];\n\t}\n};\n\nexport const generateEmoji = async (\n\ttoken: string = '',\n\tmodel: string,\n\tprompt: string,\n\tchat_id?: string\n) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/tasks/emoji/completions`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tmodel: model,\n\t\t\tprompt: prompt,\n\t\t\t...(chat_id && { chat_id: chat_id })\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\tconst response = res?.choices[0]?.message?.content.replace(/[\"']/g, '') ?? null;\n\n\tif (response) {\n\t\tif (/\\p{Extended_Pictographic}/u.test(response)) {\n\t\t\treturn response.match(/\\p{Extended_Pictographic}/gu)[0];\n\t\t}\n\t}\n\n\treturn null;\n};\n\nexport const generateQueries = async (\n\ttoken: string = '',\n\tmodel: string,\n\tmessages: object[],\n\tprompt: string,\n\ttype?: string = 'web_search'\n) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/tasks/queries/completions`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tmodel: model,\n\t\t\tmessages: messages,\n\t\t\tprompt: prompt,\n\t\t\ttype: type\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\t// Step 1: Safely extract the response string\n\tconst response = res?.choices[0]?.message?.content ?? '';\n\n\ttry {\n\t\tconst jsonStartIndex = response.indexOf('{');\n\t\tconst jsonEndIndex = response.lastIndexOf('}');\n\n\t\tif (jsonStartIndex !== -1 && jsonEndIndex !== -1) {\n\t\t\tconst jsonResponse = response.substring(jsonStartIndex, jsonEndIndex + 1);\n\n\t\t\t// Step 5: Parse the JSON block\n\t\t\tconst parsed = JSON.parse(jsonResponse);\n\n\t\t\t// Step 6: If there's a \"queries\" key, return the queries array; otherwise, return an empty array\n\t\t\tif (parsed && parsed.queries) {\n\t\t\t\treturn Array.isArray(parsed.queries) ? parsed.queries : [];\n\t\t\t} else {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\n\t\t// If no valid JSON block found, return response as is\n\t\treturn [response];\n\t} catch (e) {\n\t\t// Catch and safely return empty array on any parsing errors\n\t\tconsole.error('Failed to parse response: ', e);\n\t\treturn [response];\n\t}\n};\n\nexport const generateAutoCompletion = async (\n\ttoken: string = '',\n\tmodel: string,\n\tprompt: string,\n\tmessages?: object[],\n\ttype: string = 'search query'\n) => {\n\tconst controller = new AbortController();\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/tasks/auto/completions`, {\n\t\tsignal: controller.signal,\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tmodel: model,\n\t\t\tprompt: prompt,\n\t\t\t...(messages && { messages: messages }),\n\t\t\ttype: type,\n\t\t\tstream: false\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\tconst response = res?.choices[0]?.message?.content ?? '';\n\n\ttry {\n\t\tconst jsonStartIndex = response.indexOf('{');\n\t\tconst jsonEndIndex = response.lastIndexOf('}');\n\n\t\tif (jsonStartIndex !== -1 && jsonEndIndex !== -1) {\n\t\t\tconst jsonResponse = response.substring(jsonStartIndex, jsonEndIndex + 1);\n\n\t\t\t// Step 5: Parse the JSON block\n\t\t\tconst parsed = JSON.parse(jsonResponse);\n\n\t\t\t// Step 6: If there's a \"queries\" key, return the queries array; otherwise, return an empty array\n\t\t\tif (parsed && parsed.text) {\n\t\t\t\treturn parsed.text;\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\n\t\t// If no valid JSON block found, return response as is\n\t\treturn response;\n\t} catch (e) {\n\t\t// Catch and safely return empty array on any parsing errors\n\t\tconsole.error('Failed to parse response: ', e);\n\t\treturn response;\n\t}\n};\n\nexport const generateMoACompletion = async (\n\ttoken: string = '',\n\tmodel: string,\n\tprompt: string,\n\tresponses: string[]\n) => {\n\tconst controller = new AbortController();\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/tasks/moa/completions`, {\n\t\tsignal: controller.signal,\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tmodel: model,\n\t\t\tprompt: prompt,\n\t\t\tresponses: responses,\n\t\t\tstream: true\n\t\t})\n\t}).catch((err) => {\n\t\tconsole.error(err);\n\t\terror = err;\n\t\treturn null;\n\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn [res, controller];\n};\n\nexport const getPipelinesList = async (token: string = '') => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/pipelines/list`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\tlet pipelines = res?.data ?? [];\n\treturn pipelines;\n};\n\nexport const uploadPipeline = async (token: string, file: File, urlIdx: string) => {\n\tlet error = null;\n\n\t// Create a new FormData object to handle the file upload\n\tconst formData = new FormData();\n\tformData.append('file', file);\n\tformData.append('urlIdx', urlIdx);\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/pipelines/upload`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t\t// 'Content-Type': 'multipart/form-data' is not needed as Fetch API will set it automatically\n\t\t},\n\t\tbody: formData\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const downloadPipeline = async (token: string, url: string, urlIdx: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/pipelines/add`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\turl: url,\n\t\t\turlIdx: urlIdx\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const deletePipeline = async (token: string, id: string, urlIdx: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/pipelines/delete`, {\n\t\tmethod: 'DELETE',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tid: id,\n\t\t\turlIdx: urlIdx\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getPipelines = async (token: string, urlIdx?: string) => {\n\tlet error = null;\n\n\tconst searchParams = new URLSearchParams();\n\tif (urlIdx !== undefined) {\n\t\tsearchParams.append('urlIdx', urlIdx);\n\t}\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/v1/pipelines/?${searchParams.toString()}`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\tlet pipelines = res?.data ?? [];\n\treturn pipelines;\n};\n\nexport const getPipelineValves = async (token: string, pipeline_id: string, urlIdx: string) => {\n\tlet error = null;\n\n\tconst searchParams = new URLSearchParams();\n\tif (urlIdx !== undefined) {\n\t\tsearchParams.append('urlIdx', urlIdx);\n\t}\n\n\tconst res = await fetch(\n\t\t`${WEBUI_BASE_URL}/api/v1/pipelines/${pipeline_id}/valves?${searchParams.toString()}`,\n\t\t{\n\t\t\tmethod: 'GET',\n\t\t\theaders: {\n\t\t\t\tAccept: 'application/json',\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t\t}\n\t\t}\n\t)\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getPipelineValvesSpec = async (token: string, pipeline_id: string, urlIdx: string) => {\n\tlet error = null;\n\n\tconst searchParams = new URLSearchParams();\n\tif (urlIdx !== undefined) {\n\t\tsearchParams.append('urlIdx', urlIdx);\n\t}\n\n\tconst res = await fetch(\n\t\t`${WEBUI_BASE_URL}/api/v1/pipelines/${pipeline_id}/valves/spec?${searchParams.toString()}`,\n\t\t{\n\t\t\tmethod: 'GET',\n\t\t\theaders: {\n\t\t\t\tAccept: 'application/json',\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t\t}\n\t\t}\n\t)\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const updatePipelineValves = async (\n\ttoken: string = '',\n\tpipeline_id: string,\n\tvalves: object,\n\turlIdx: string\n) => {\n\tlet error = null;\n\n\tconst searchParams = new URLSearchParams();\n\tif (urlIdx !== undefined) {\n\t\tsearchParams.append('urlIdx', urlIdx);\n\t}\n\n\tconst res = await fetch(\n\t\t`${WEBUI_BASE_URL}/api/v1/pipelines/${pipeline_id}/valves/update?${searchParams.toString()}`,\n\t\t{\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\tAccept: 'application/json',\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t...(token && { authorization: `Bearer ${token}` })\n\t\t\t},\n\t\t\tbody: JSON.stringify(valves)\n\t\t}\n\t)\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\n\t\t\tif ('detail' in err) {\n\t\t\t\terror = err.detail;\n\t\t\t} else {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getUsage = async (token: string = '') => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/usage`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\t...(token && { Authorization: `Bearer ${token}` })\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getBackendConfig = async () => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/config`, {\n\t\tmethod: 'GET',\n\t\tcredentials: 'include',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json'\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getChangelog = async () => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/changelog`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json'\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getVersionUpdates = async (token: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/version/updates`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getModelFilterConfig = async (token: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/config/model/filter`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const updateModelFilterConfig = async (\n\ttoken: string,\n\tenabled: boolean,\n\tmodels: string[]\n) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/config/model/filter`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tenabled: enabled,\n\t\t\tmodels: models\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getWebhookUrl = async (token: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/webhook`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res.url;\n};\n\nexport const updateWebhookUrl = async (token: string, url: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/webhook`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\turl: url\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res.url;\n};\n\nexport const getCommunitySharingEnabledStatus = async (token: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/community_sharing`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const toggleCommunitySharingEnabledStatus = async (token: string) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/community_sharing/toggle`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\terror = err.detail;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n\nexport const getModelConfig = async (token: string): Promise<GlobalModelConfig> => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/config/models`, {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t}\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res.models;\n};\n\nexport interface ModelConfig {\n\tid: string;\n\tname: string;\n\tmeta: ModelMeta;\n\tbase_model_id?: string;\n\tparams: ModelParams;\n}\n\nexport interface ModelMeta {\n\tdescription?: string;\n\tcapabilities?: object;\n\tprofile_image_url?: string;\n}\n\nexport interface ModelParams {}\n\nexport type GlobalModelConfig = ModelConfig[];\n\nexport const updateModelConfig = async (token: string, config: GlobalModelConfig) => {\n\tlet error = null;\n\n\tconst res = await fetch(`${WEBUI_BASE_URL}/api/config/models`, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${token}`\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tmodels: config\n\t\t})\n\t})\n\t\t.then(async (res) => {\n\t\t\tif (!res.ok) throw await res.json();\n\t\t\treturn res.json();\n\t\t})\n\t\t.catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\terror = err;\n\t\t\treturn null;\n\t\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\n\treturn res;\n};\n"],"names":["map","YAMLMap","onError","isMap","schema","obj","ctx","seq","YAMLSeq","isSeq","string","value","str","item","onComment","onChompKeep","stringifyString","nullTag","Scalar","source","boolTag","sv","stringifyNumber","format","minFractionDigits","tag","num","n","i","d","floatNaN","floatExp","node","float","dot","intIdentify","intResolve","offset","radix","intAsBigInt","intStringify","prefix","intOct","_onError","opt","int","intHex","stringifyJSON","jsonScalars","jsonError","binary","src","buffer","comment","type","buf","s","lineWidth","lines","o","boolStringify","trueTag","falseTag","f","sign","intBin","parseSexagesimal","asBigInt","parts","res","p","stringifySexagesimal","_60","intTime","floatTime","timestamp","match","year","month","day","hour","minute","second","millisec","date","tz","merge","omap","pairs","set","schemas","schema$1","schema$2","tagsByName","coreKnownTags","getTags","customTags","schemaName","addMergeTag","schemaTags","tags","keys","key","tagObj","tagName","sortMapEntriesByKey","a","b","Schema","compat","resolveKnownTags","sortMapEntries","toStringDefaults","MAP","SCALAR","SEQ","copy","stringifyDocument","doc","options","hasDirectives","dir","createStringifyContext","commentString","cs","indentComment","chompKeep","contentComment","isNode","body","stringify","lineComment","_a","dc","Document","replacer","NODE_TYPE","DOC","_replacer","version","Directives","assertCollection","path","name","prev","anchorNames","findNewAnchor","Alias","keyToStr","v","asStr","aliasDuplicateObjects","anchorPrefix","flow","keepUndefined","onTagObj","onAnchor","setAnchors","sourceObjects","createNodeAnchors","createNode","isCollection","k","Pair","isEmptyPath","keepScalar","isScalar","collectionFromPath","json","jsonArg","mapAsMap","maxAliasCount","reviver","toJS","count","applyReviver","contents","YAMLError","pos","code","message","YAMLParseError","YAMLWarning","prettifyError","lc","error","line","col","ci","lineStr","trimStart","end","pointer","resolveProps","tokens","indicator","next","parentIndent","startOnNewline","spaceBefore","atNewline","hasSpace","commentSep","hasNewline","reqSpace","tab","anchor","newlineAfterProp","comma","found","start","token","cb","last","containsNewline","st","it","flowIndentCheck","indent","fc","mapIncludes","items","search","uniqueKeys","isEqual","pair","startColMsg","resolveBlockMap","composeNode","composeEmptyNode","bm","NodeClass","commentEnd","collItem","sep","keyProps","implicitKey","keyStart","keyNode","valueProps","valueNode","resolveBlockSeq","bs","props","resolveEnd","blockMsg","isBlock","resolveFlowCollection","fcName","coll","atRoot","prevItemComment","loop","isPair","endRange","expectedEnd","ce","ee","cePos","msg","resolveCollection","CN","Coll","composeCollection","tagToken","nl","lastProp","expType","t","kt","resolveBlockScalar","scalar","header","parseBlockScalarHeader","splitLines","chompStart","content","trimIndent","contentStart","prevMoreIndented","crlf","strict","mode","chomp","ch","length","ts","split","first","m","resolveFlowScalar","_type","rel","plainValue","singleQuotedValue","doubleQuotedValue","valueEnd","re","badChar","foldLines","fold","foldNewline","cc","escapeCodes","parseCharCode","raw","wsStart","composeScalar","range","findScalarTagByName","findScalarTagByTest","matchWithTest","atKey","directives","emptyScalarPosition","before","isSrcToken","composeAlias","alias","composeDoc","opts","contentEnd","getErrorPos","parsePrelude","prelude","atComment","afterEmptyLine","Composer","warning","afterDoc","forceDoc","endOffset","LineCounter","low","high","mid","includesToken","list","findNonEmptyIndex","isFlowToken","getPrevProps","parent","getFirstKeyStartProps","fixFlowSeqItems","Parser","onNewLine","Lexer","incomplete","lexeme","tokenType","top","bv","atMapIndent","atNextItem","fs","docEnd","parseOptions","prettyErrors","parseDocument","lineCounter","parser","composer","_doc","parse","_reviver","warn","getModels","connections","base","WEBUI_BASE_URL","err","models","localModels","OPENAI_API_BASE_URLS","OPENAI_API_KEYS","OPENAI_API_CONFIGS","requests","idx","url","apiConfig","enable","modelIds","modelList","modelId","getOpenAIModelsDirect","responses","response","model","prefixId","modelsMap","chatCompleted","chatAction","action_id","stopTask","id","getTaskIdsByChatId","chat_id","getToolServerData","text","convertOpenApiToToolPayload","getToolServersData","i18n","servers","server","data","toast","openapi","info","specs","executeToolServer","params","serverData","matchingRoute","_","methods","__","operation","routePath","methodEntry","httpMethod","pathParams","queryParams","bodyParams","param","paramName","paramIn","finalUrl","queryString","contentType","headers","requestOptions","resText","getTaskConfig","updateTaskConfig","config","generateTitle","messages","sanitizedResponse","_b","jsonStartIndex","jsonEndIndex","jsonResponse","parsed","e","generateTags","generateEmoji","prompt","generateAutoCompletion","controller","generateMoACompletion","getPipelinesList","uploadPipeline","file","urlIdx","formData","downloadPipeline","deletePipeline","getPipelines","searchParams","getPipelineValves","pipeline_id","getPipelineValvesSpec","updatePipelineValves","valves","getUsage","getBackendConfig","getChangelog","getVersionUpdates","getWebhookUrl","updateWebhookUrl"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39]}